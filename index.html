<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Art Studio</title>
  <style>
    :root{
      --bg:#0b0e14;
      --panel:#121826;
      --panel-2:#0f172a;
      --border:#1f2937;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#8b5cf6;
      --accent-hover:#7c3aed;
      --danger:#ef4444;
      --grid:#374151;
    }
    body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial, Helvetica, sans-serif; display:flex; flex-direction:column; align-items:center; padding:20px; }
    h1,h3,h4{ color:var(--text); }
    #toolbar{ display:flex; gap:16px; margin-bottom:14px; flex-wrap:wrap; align-items:flex-start; background:var(--panel); padding:12px; border-radius:12px; box-shadow:0 10px 25px rgba(0,0,0,.35); border:1px solid var(--border); }
    .toolbox-group{ display:flex; flex-direction:column; gap:8px; background:var(--panel-2); padding:10px; border-radius:10px; box-shadow: inset 0 0 0 1px var(--border); }
    .toolbox-group h4{ margin:0 0 6px 0; font-size:12px; letter-spacing:1px; text-transform:uppercase; color:var(--muted); }
    .toolbox-row{ display:flex; gap:6px; flex-wrap:wrap; }
    button, select, input{ padding:6px 10px; font-size:14px; border-radius:8px; border:1px solid var(--border); background:#0b1220; color:var(--text); cursor:pointer; }
    button:hover, select:hover, input:hover{ background:#111827; }
    button.activeTool{ background:var(--accent); border-color:var(--accent); color:white; }
    select option{ background:#0b1220; color:var(--text); }
    .color-btn{ width:28px; height:28px; border:1px solid #000; cursor:pointer; box-sizing:border-box; display:inline-block; border-radius:6px; }
    .color-btn.selected{ outline:3px solid var(--accent); }
    #grid{ background:white; border-radius:12px; image-rendering:pixelated; cursor:crosshair; touch-action:none; width:640px; height:640px; box-shadow:0 10px 30px rgba(0,0,0,.45); }
    #colorHistory{ display:flex; flex-wrap:wrap; gap:5px; margin-top:10px; max-width:320px; max-height:300px; overflow:auto; padding:8px; background:transparent; }
    #colorHistory::-webkit-scrollbar{ height:1000px; width:20px; }
    #colorHistory::-webkit-scrollbar-thumb{ background:var(--border); border-radius:4px; }
    #colorHistory::-webkit-scrollbar-track{ background:#020617; }
    #customColor{ width:90px; }
    .activeTool{ outline:30000px solid rgba(139,92,246,0.08); }
    
    /* TIMELINE STYLES */
    #timeline-container {
      margin-top: 20px;
      background: var(--panel);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
      border: 1px solid var(--border);
      width: 100%;
      max-width: 800px;
    }
    
    #timeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    #timeline-controls {
      display: flex;
      gap: 10px;
    }
    
    #frames-container {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding: 10px;
      background: var(--panel-2);
      border-radius: 8px;
      min-height: 150px;
    }
    
    .frame {
      position: relative;
      min-width: 120px;
      height: 120px;
      background: #0b1220;
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .frame.active {
      border-color: var(--accent);
    }
    
    .frame canvas {
      width: 80px;
      height: 80px;
      image-rendering: pixelated;
      background: white;
    }
    
    .frame-number {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
    }
    
    .frame-duration {
      position: absolute;
      bottom: 5px;
      font-size: 11px;
      color: var(--muted);
    }
    
    .frame-actions {
      position: absolute;
      top: 5px;
      right: 5px;
      display: flex;
      gap: 3px;
    }
    
    .frame-btn {
      width: 20px;
      height: 20px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }
    
    #animation-preview {
      margin-top: 20px;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    #preview-canvas {
      background: white;
      border-radius: 8px;
      image-rendering: pixelated;
    }
    
    #preview-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    #playback-speed {
      width: 100px;
    }
    
    /* Frame duration controls */
    .frame-duration-controls {
      position: absolute;
      bottom: 5px;
      right: 5px;
      display: flex;
      gap: 2px;
    }
    
    .duration-btn {
      width: 18px;
      height: 18px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 2px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
    }
    
    .duration-btn:hover {
      background: var(--accent);
    }
    
    /* Custom speed input */
    #custom-speed-container {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-top: 10px;
    }
    
    #custom-speed-input {
      width: 80px;
      padding: 4px 8px;
    }
    
    #apply-custom-speed {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    /* Layout principal reorganizado */
    .main-content {
      display: flex;
      flex-direction:column;
      align-items: center;
      gap: 20px;
    }
    
    .canvas-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .canvas-with-tools {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    
    .tools-sidebar {
      display: flex;
      flex-direction: column;
      width: 200px;
    }

    /* Modal de importação */
    .import-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .import-modal-content {
      background: var(--panel);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid var(--border);
      width: 400px;
      max-width: 90%;
    }

    .import-options {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 15px;
    }

    .import-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--panel-2);
      border-radius: 8px;
      cursor: pointer;
      border: 1px solid var(--border);
    }

    .import-option:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .import-option input[type="radio"] {
      margin: 0;
    }

    .import-controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .import-control-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .import-control-row label {
      min-width: 150px;
      color: var(--muted);
    }

    .import-control-row input[type="number"] {
      width: 80px;
      padding: 6px 10px;
    }

    .import-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h1>Pixel Art Studio</h1>

<div class="main-content">
  <!-- TOOLBOX (ACIMA DO GRID) -->
  <div id="toolbar">

    <div class="toolbox-group">
      <h4>Arquivo</h4>
      <div class="toolbox-row">
        <button id="newArt">Nova Arte</button>
        <button id="download">Baixar</button>
        <button id="downloadTransparent">PNG</button>
        <button id="importBtn">Importar</button>
      </div>
    </div>

    <div class="toolbox-group">
      <h4>Editar</h4>
      <div class="toolbox-row">
        <button id="undoBtn">Desfazer</button>
        <button id="redoBtn">Refazer</button>
        <button id="eraser">Borracha</button>
      </div>
    </div>

    <div class="toolbox-group">
      <h4>Grid</h4>
      <div class="toolbox-row">
        <button id="toggleGrid" class="activeTool">Grid ON</button>
        <button id="toggleExportGrid" class="activeTool">Grid no Download</button>
      </div>
      <div class="toolbox-row">
        <label for="gridSize">Tamanho</label>
        <select id="gridSize">
          <option value="16" >16 x 16</option>
          <option value="32">32 x 32</option>
          <option value="64" selected>64 x 64</option>
          <option value="128">128 x 128</option>
          <option value="256">256 x 256</option>
        </select>
        <button id="createGrid">Criar Grid</button>
      </div>
    </div>

    <div class="toolbox-group">
      <h4>Cores</h4>
      <div class="toolbox-row">
        <input type="text" id="customColor" placeholder="#hex" />
        <button id="addColor">Criar Cor</button>
      </div>
      <div class="toolbox-row">
        <label style="font-size:12px;color:var(--muted)">Accent</label>
        <input type="color" id="accentPicker" value="#8b5cf6" />
      </div>
    </div>

  </div>

  <!-- SEÇÃO DO CANVAS E FERRAMENTAS -->
  <div class="canvas-section">
    <div class="canvas-with-tools">
      <!-- CANVAS -->
      <div>
        <canvas id="grid" width="640" height="640"></canvas>
      </div>

      <!-- HISTÓRICO DE CORES (LATERAL DO GRID) -->
      <div class="tools-sidebar">
        <h4 style="margin:0 0 10px 0; color:var(--muted)">Cores Recentes</h4>
        <div id="colorHistory"></div>
      </div>
    </div>
  </div>

  <!-- TIMELINE DE ANIMAÇÃO (ABAIXO DO GRID) -->
  <div id="timeline-container">
    <div id="timeline-header">
      <h3 style="margin:0;">Timeline de Animação</h3>
      <div id="timeline-controls">
        <button id="addFrame">+ Frame</button>
        <button id="duplicateFrame">Duplicar</button>
        <button id="deleteFrame">Remover</button>
        <button id="previewAnimation">Preview</button>
        <button id="exportGIF">Exportar GIF</button>
      </div>
    </div>
    
    <div id="frames-container">
      <!-- Frames serão adicionados aqui dinamicamente -->
    </div>
    
    <!-- Controle de velocidade customizada -->
    <div id="custom-speed-container">
      <span style="font-size:12px; color:var(--muted)">Velocidade customizada (ms):</span>
      <input type="number" id="custom-speed-input" min="50" max="2000" step="50" value="250" />
      <button id="apply-custom-speed">Aplicar</button>
      <button id="apply-all-speed">Aplicar a todos</button>
    </div>
    
    <div id="animation-preview">
      <canvas id="preview-canvas" width="320" height="320"></canvas>
      <div id="preview-controls">
        <button id="playPause">▶ Play</button>
        <button id="stopPreview">⏹ Stop</button>
        <span>Velocidade:</span>
        <select id="playback-speed">
          <option value="1000">0.25x</option>
          <option value="500">0.5x</option>
          <option value="250" selected>1x</option>
          <option value="125">2x</option>
          <option value="62">4x</option>
          <option value="custom">Custom</option>
        </select>
        <span id="frame-counter">Frame: 1/1</span>
      </div>
    </div>
  </div>
</div>

<!-- Modal de importação -->
<div id="importModal" class="import-modal">
  <div class="import-modal-content">
    <h3 style="margin:0 0 15px 0;">Importar Imagem</h3>
    <div class="import-options">
      <label class="import-option">
        <input type="radio" name="importOption" value="fitToGrid" checked>
        <span>Ajustar ao grid atual</span>
      </label>
      <label class="import-option">
        <input type="radio" name="importOption" value="adaptGrid">
        <span>Adaptar grid à imagem</span>
      </label>
    </div>
    
    <div class="import-controls" id="adaptiveControls" style="display:none;">
      <div class="import-control-row">
        <label>Colunas (largura):</label>
        <input type="number" id="importCols" min="8" max="512" value="64">
      </div>
      <div class="import-control-row">
        <label>Linhas (altura):</label>
        <input type="number" id="importRows" min="8" max="512" value="64">
      </div>
      <div style="font-size:12px; color:var(--muted); margin-top:10px;">
        Dica: Use valores altos para mais detalhes, valores baixos para pixel art mais estilizada.
      </div>
    </div>

    <div class="import-controls" id="fitControls">
      <div style="font-size:12px; color:var(--muted);">
        A imagem será redimensionada para caber no grid atual de <span id="currentGridSize">64x64</span> pixels.
      </div>
    </div>

    <div class="import-buttons">
      <button id="cancelImport">Cancelar</button>
      <button id="confirmImport">Importar</button>
    </div>
  </div>
</div>

<script>
// accent color control
const accentPicker = document.getElementById('accentPicker');
accentPicker.addEventListener('input', (e)=>{
  const color = e.target.value;
  document.documentElement.style.setProperty('--accent', color);
  // darker hover automatically
  document.documentElement.style.setProperty('--accent-hover', color);
});

// --- setup ---
const artCanvas = document.getElementById('grid');
const ctx = artCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// offscreen buffer that stores pixel artwork (without grid)
const buffer = document.createElement('canvas');
const bctx = buffer.getContext('2d');
buffer.width = artCanvas.width;
buffer.height = artCanvas.height;

// state
let size = 64; // backward compatibility (square)
let gridCols = 64;
let gridRows = 64;
let cell = artCanvas.width / size;
let currentColor = '#000000';
let colorHistory = [];
let isDrawing = false;
let showGrid = true; // grid de visualização
let includeGridOnExport = true; // grid no download

// undo/redo (store buffer dataURLs)
const undoStack = [];
const redoStack = [];

// TIMELINE STATE
let frames = [];
let currentFrameIndex = 0;
let isPlaying = false;
let playInterval = null;

// VARIÁVEIS PARA IMPORTAR
let importImageData = null;
let importImageWidth = 0;
let importImageHeight = 0;

function pushUndo(){
  try{
    undoStack.push(buffer.toDataURL());
    if(undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
  }catch(e){console.warn('save failed',e);} 
}

function restoreBuffer(dataURL, callback){
  const img = new Image();
  img.onload = () => {
    bctx.clearRect(0,0,buffer.width,buffer.height);
    bctx.drawImage(img,0,0);
    renderAll();
    if(callback) callback();
  };
  img.src = dataURL;
}

function undo(){ if(undoStack.length===0) return; redoStack.push(buffer.toDataURL()); const last = undoStack.pop(); restoreBuffer(last); updateUndoRedoButtons(); }
function redo(){ if(redoStack.length===0) return; undoStack.push(buffer.toDataURL()); const next = redoStack.pop(); restoreBuffer(next); updateUndoRedoButtons(); }
function updateUndoRedoButtons(){ document.getElementById('undoBtn').disabled = undoStack.length===0; document.getElementById('redoBtn').disabled = redoStack.length===0; }

// draw grid path once per render to avoid double-stroke at intersections
function drawGridOnContext(targetCtx){
  const path = new Path2D();
  const cw = targetCtx === ctx ? artCanvas.width : buffer.width;
  const ch = targetCtx === ctx ? artCanvas.height : buffer.height;

  const stepX = cw / gridCols;
  const stepY = ch / gridRows;

  targetCtx.lineWidth = 0.7; // grid mais visível
  targetCtx.strokeStyle = '#8a8a8a';

  // linhas verticais
  for(let i = 0; i <= gridCols; i++){
    const x = Math.round(i * stepX) + 0.5;
    path.moveTo(x, 0);
    path.lineTo(x, ch);
  }

  // linhas horizontais
  for(let j = 0; j <= gridRows; j++){
    const y = Math.round(j * stepY) + 0.5;
    path.moveTo(0, y);
    path.lineTo(cw, y);
  }

  targetCtx.stroke(path);

  // contorno final (direita e embaixo garantidos)
  targetCtx.strokeRect(0.5, 0.5, cw - 1, ch - 1);
}

// render: draw buffer (pixels) then grid on top
function renderAll(){
  ctx.clearRect(0,0,artCanvas.width,artCanvas.height);
  ctx.drawImage(buffer, 0, 0);
  if(showGrid){
    drawGridOnContext(ctx);
  }
}

function resizeBufferToCanvas(){ buffer.width = artCanvas.width; buffer.height = artCanvas.height; }

function paintCellAt(xPixel, yPixel){
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;

  const x = Math.floor(xPixel / stepX);
  const y = Math.floor(yPixel / stepY);
  if(x < 0 || y < 0 || x >= gridCols || y >= gridRows) return;

  const px = Math.round(x * stepX);
  const py = Math.round(y * stepY);
  const w = Math.ceil(stepX);
  const h = Math.ceil(stepY);

  bctx.imageSmoothingEnabled = false;

  if(currentColor === 'eraser'){
    // apaga de verdade (transparência real para PNG)
    bctx.clearRect(px, py, w, h);
  } else {
    bctx.fillStyle = currentColor;
    bctx.fillRect(px, py, w, h);
  }

  renderAll();
}

function getPointerPos(evt){
  const rect = artCanvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const xCss = clientX - rect.left;
  const yCss = clientY - rect.top;
  const scaleX = artCanvas.width / rect.width;
  const scaleY = artCanvas.height / rect.height;
  return { x: xCss * scaleX, y: yCss * scaleY };
}

// events
artCanvas.addEventListener('pointerdown', (e)=>{
  // left button only (button === 0)
  if(e.button !== undefined && e.button !== 0) return;
  pushUndo(); // save state before edit
  isDrawing = true;
  const pos = getPointerPos(e);
  paintCellAt(pos.x, pos.y);
  e.preventDefault();
});
window.addEventListener('pointerup', ()=>{ isDrawing = false; });
artCanvas.addEventListener('pointermove', (e)=>{ if(!isDrawing) return; const pos = getPointerPos(e); paintCellAt(pos.x, pos.y); e.preventDefault(); });

// toolbar actions
document.getElementById('newArt').onclick = ()=>{ pushUndo(); bctx.clearRect(0,0,buffer.width,buffer.height); renderAll(); };
document.getElementById('gridSize').onchange = (e)=>{
  const v = parseInt(e.target.value,10)||64;
  gridCols = v;
  gridRows = v;
  renderAll();
};

// Modal de importação
const importModal = document.getElementById('importModal');
const importOptionRadios = document.querySelectorAll('input[name="importOption"]');
const adaptiveControls = document.getElementById('adaptiveControls');
const fitControls = document.getElementById('fitControls');
const currentGridSizeSpan = document.getElementById('currentGridSize');
const importColsInput = document.getElementById('importCols');
const importRowsInput = document.getElementById('importRows');
const cancelImportBtn = document.getElementById('cancelImport');
const confirmImportBtn = document.getElementById('confirmImport');

// Atualizar tamanho do grid atual
function updateCurrentGridSize() {
  currentGridSizeSpan.textContent = `${gridCols}x${gridRows}`;
}

// Mostrar/ocultar controles baseado na opção selecionada
importOptionRadios.forEach(radio => {
  radio.addEventListener('change', (e) => {
    if (e.target.value === 'adaptGrid') {
      adaptiveControls.style.display = 'block';
      fitControls.style.display = 'none';
      
      // Sugerir valores baseados na proporção da imagem
      if (importImageWidth > 0 && importImageHeight > 0) {
        const aspectRatio = importImageWidth / importImageHeight;
        
        // Calcular valores sugeridos mantendo a proporção
        let suggestedCols = 64;
        let suggestedRows = Math.round(suggestedCols / aspectRatio);
        
        // Garantir valores mínimos
        if (suggestedRows < 8) {
          suggestedRows = 8;
          suggestedCols = Math.round(suggestedRows * aspectRatio);
        }
        
        // Limitar valores máximos
        suggestedCols = Math.min(512, Math.max(8, suggestedCols));
        suggestedRows = Math.min(512, Math.max(8, suggestedRows));
        
        importColsInput.value = suggestedCols;
        importRowsInput.value = suggestedRows;
      }
    } else {
      adaptiveControls.style.display = 'none';
      fitControls.style.display = 'block';
    }
  });
});

cancelImportBtn.onclick = () => {
  importModal.style.display = 'none';
  importImageData = null;
};

// Importar imagem
document.getElementById('importBtn').onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        // Salvar dados da imagem para usar no modal
        importImageData = event.target.result;
        importImageWidth = img.width;
        importImageHeight = img.height;
        
        // Atualizar tamanho do grid atual no modal
        updateCurrentGridSize();
        
        // Mostrar modal de importação
        importModal.style.display = 'flex';
        
        // Resetar para opção padrão
        document.querySelector('input[name="importOption"][value="fitToGrid"]').checked = true;
        adaptiveControls.style.display = 'none';
        fitControls.style.display = 'block';
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  };
  
  input.click();
};

// Confirmar importação
confirmImportBtn.onclick = () => {
  if (!importImageData) return;
  
  const importOption = document.querySelector('input[name="importOption"]:checked').value;
  
  const img = new Image();
  img.onload = () => {
    // Salvar estado atual no undo
    pushUndo();
    
    if (importOption === 'adaptGrid') {
      // ADAPTAR GRID À IMAGEM
      const newCols = parseInt(importColsInput.value);
      const newRows = parseInt(importRowsInput.value);
      
      if (isNaN(newCols) || isNaN(newRows) || newCols < 8 || newCols > 512 || newRows < 8 || newRows > 512) {
        alert('Por favor, insira valores válidos para colunas e linhas (8-512).');
        return;
      }
      
      // Atualizar tamanho do grid
      gridCols = newCols;
      gridRows = newRows;
      
      // Atualizar select do grid para refletir o novo tamanho
      document.getElementById('gridSize').value = newCols === newRows ? newCols.toString() : 'custom';
      
      // Calcular novo tamanho do canvas mantendo proporção
      const canvasSize = 640;
      const aspectRatio = newCols / newRows;
      
      if (aspectRatio >= 1) {
        artCanvas.width = canvasSize;
        artCanvas.height = Math.round(canvasSize / aspectRatio);
      } else {
        artCanvas.height = canvasSize;
        artCanvas.width = Math.round(canvasSize * aspectRatio);
      }
      
      // Atualizar buffer
      buffer.width = artCanvas.width;
      buffer.height = artCanvas.height;
      
      // Limpar buffer
      bctx.clearRect(0, 0, buffer.width, buffer.height);
      
      // Calcular escala para preencher o canvas
      const scaleX = buffer.width / img.width;
      const scaleY = buffer.height / img.height;
      const scale = Math.max(scaleX, scaleY); // Preencher todo o canvas
      
      const newWidth = img.width * scale;
      const newHeight = img.height * scale;
      
      // Centralizar a imagem no canvas
      const offsetX = (buffer.width - newWidth) / 2;
      const offsetY = (buffer.height - newHeight) / 2;
      
      // Desenhar imagem redimensionada
      bctx.imageSmoothingEnabled = false;
      bctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
      
      // Aplicar pixelização baseada no novo grid
      pixelateImageForGrid(newWidth, newHeight, offsetX, offsetY);
      
    } else {
      // AJUSTAR AO GRID ATUAL
      // Limpar buffer
      bctx.clearRect(0, 0, buffer.width, buffer.height);
      
      // Calcular proporções para redimensionar imagem para o grid
      const scaleX = buffer.width / img.width;
      const scaleY = buffer.height / img.height;
      const scale = Math.min(scaleX, scaleY); // Manter proporção
      
      const newWidth = img.width * scale;
      const newHeight = img.height * scale;
      
      // Centralizar a imagem no canvas
      const offsetX = (buffer.width - newWidth) / 2;
      const offsetY = (buffer.height - newHeight) / 2;
      
      // Desenhar imagem redimensionada
      bctx.imageSmoothingEnabled = false;
      bctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
      
      // Aplicar pixelização para melhorar a visualização pixel art
      pixelateImage(newWidth, newHeight, offsetX, offsetY);
    }
    
    // Atualizar display
    renderAll();
    
    // Se estiver na timeline, atualizar o frame atual
    if (frames.length > 0 && frames[currentFrameIndex]) {
      const frameCanvas = document.createElement('canvas');
      frameCanvas.width = buffer.width;
      frameCanvas.height = buffer.height;
      const frameCtx = frameCanvas.getContext('2d');
      frameCtx.drawImage(buffer, 0, 0);
      frames[currentFrameIndex].imageData = frameCanvas.toDataURL();
      renderFrames();
    }
    
    // Fechar modal
    importModal.style.display = 'none';
    importImageData = null;
    
    alert('Imagem importada com sucesso!');
  };
  img.src = importImageData;
};

// Função para pixelar a imagem importada (para ajustar ao grid atual)
function pixelateImage(imgWidth, imgHeight, offsetX, offsetY) {
  // Obter dados da imagem original
  const imageData = bctx.getImageData(offsetX, offsetY, imgWidth, imgHeight);
  const data = imageData.data;
  
  // Tamanho do "pixel" baseado no grid
  const pixelSize = Math.max(1, Math.floor(imgWidth / gridCols));
  
  // Aplicar efeito de pixelização
  for (let y = 0; y < imgHeight; y += pixelSize) {
    for (let x = 0; x < imgWidth; x += pixelSize) {
      // Pegar a cor do pixel central do bloco
      const centerX = Math.min(x + Math.floor(pixelSize / 2), imgWidth - 1);
      const centerY = Math.min(y + Math.floor(pixelSize / 2), imgHeight - 1);
      const index = (centerY * imgWidth + centerX) * 4;
      
      const r = data[index];
      const g = data[index + 1];
      const b = data[index + 2];
      const a = data[index + 3];
      
      // Preencher o bloco inteiro com essa cor
      for (let py = 0; py < pixelSize; py++) {
        for (let px = 0; px < pixelSize; px++) {
          const currentX = x + px;
          const currentY = y + py;
          
          if (currentX < imgWidth && currentY < imgHeight) {
            const currentIndex = (currentY * imgWidth + currentX) * 4;
            data[currentIndex] = r;
            data[currentIndex + 1] = g;
            data[currentIndex + 2] = b;
            data[currentIndex + 3] = a;
          }
        }
      }
    }
  }
  
  // Colocar os dados pixelados de volta no buffer
  bctx.putImageData(imageData, offsetX, offsetY);
}

// Função para pixelar imagem quando o grid é adaptado
function pixelateImageForGrid(imgWidth, imgHeight, offsetX, offsetY) {
  // Obter dados da imagem original
  const imageData = bctx.getImageData(offsetX, offsetY, imgWidth, imgHeight);
  const data = imageData.data;
  
  // Tamanho do pixel baseado no novo grid
  const pixelWidth = imgWidth / gridCols;
  const pixelHeight = imgHeight / gridRows;
  
  // Aplicar efeito de pixelização para o novo grid
  for (let row = 0; row < gridRows; row++) {
    for (let col = 0; col < gridCols; col++) {
      // Calcular posição do pixel no grid
      const xStart = Math.floor(col * pixelWidth);
      const yStart = Math.floor(row * pixelHeight);
      const xEnd = Math.floor((col + 1) * pixelWidth);
      const yEnd = Math.floor((row + 1) * pixelHeight);
      
      // Calcular cor média da área
      let r = 0, g = 0, b = 0, a = 0;
      let count = 0;
      
      for (let y = yStart; y < yEnd && y < imgHeight; y++) {
        for (let x = xStart; x < xEnd && x < imgWidth; x++) {
          const index = (y * imgWidth + x) * 4;
          r += data[index];
          g += data[index + 1];
          b += data[index + 2];
          a += data[index + 3];
          count++;
        }
      }
      
      if (count > 0) {
        r = Math.round(r / count);
        g = Math.round(g / count);
        b = Math.round(b / count);
        a = Math.round(a / count);
        
        // Preencher toda a área com a cor média
        for (let y = yStart; y < yEnd && y < imgHeight; y++) {
          for (let x = xStart; x < xEnd && x < imgWidth; x++) {
            const index = (y * imgWidth + x) * 4;
            data[index] = r;
            data[index + 1] = g;
            data[index + 2] = b;
            data[index + 3] = a;
          }
        }
      }
    }
  }
  
  // Colocar os dados pixelados de volta no buffer
  bctx.putImageData(imageData, offsetX, offsetY);
}

// download PNG com fundo (respeita opção de grid no download)
document.getElementById('download').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // fundo branco
  tctx.fillStyle = "white";
  tctx.fillRect(0, 0, tmp.width, tmp.height);

  // arte
  tctx.drawImage(buffer,0,0);

  // grid opcional no export
  if(includeGridOnExport){
    drawGridOnContext(tctx);
  }

  const link = document.createElement('a');
  link.download = 'pixel_art.png';
  link.href = tmp.toDataURL('image/png');
  link.click();
};

// download PNG transparente
document.getElementById('downloadTransparent').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // transparente por padrão
  tctx.clearRect(0, 0, tmp.width, tmp.height);

  // arte
  tctx.drawImage(buffer,0,0);

  // grid opcional no export
  if(includeGridOnExport){
    drawGridOnContext(tctx);
  }

  const link = document.createElement('a');
  link.download = 'pixel_art_transparente.png';
  link.href = tmp.toDataURL('image/png');
  link.click();
};

// eraser button toggle
const eraserBtn = document.getElementById('eraser');
eraserBtn.onclick = ()=>{ currentColor = (currentColor === 'eraser') ? '#000000' : 'eraser'; eraserBtn.classList.toggle('activeTool', currentColor === 'eraser'); };

// grid toggle (visualização)
const toggleGridBtn = document.getElementById('toggleGrid');
toggleGridBtn.onclick = ()=>{
  showGrid = !showGrid;
  toggleGridBtn.textContent = showGrid ? 'Grid ON' : 'Grid OFF';
  toggleGridBtn.classList.toggle('activeTool', showGrid);
  renderAll();
};

// grid no download toggle
const toggleExportGridBtn = document.getElementById('toggleExportGrid');
toggleExportGridBtn.onclick = ()=>{
  includeGridOnExport = !includeGridOnExport;
  toggleExportGridBtn.textContent = includeGridOnExport ? 'Grid no Download' : 'Sem Grid no Download';
  toggleExportGridBtn.classList.toggle('activeTool', includeGridOnExport);
};

// undo/redo buttons
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// color history
function addColorToHistory(hex){ if(!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)) return; if(!colorHistory.includes(hex)){ colorHistory.push(hex); const div = document.getElementById('colorHistory'); const btn = document.createElement('div'); btn.className='color-btn'; btn.style.background=hex; btn.title=hex; btn.onclick = ()=>{
        currentColor = hex;
        eraserBtn.classList.remove('activeTool');
        document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected'));
        btn.classList.add('selected');
      }; div.appendChild(btn); } }

document.getElementById('addColor').onclick = ()=>{ const hex = document.getElementById('customColor').value.trim(); if(/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)){ addColorToHistory(hex); currentColor = hex; eraserBtn.classList.remove('activeTool'); document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected')); const last = document.querySelector('#colorHistory .color-btn:last-child'); if(last) last.classList.add('selected'); } else alert('HEX inválido. Use #fff ou #1a2b3c'); };

// create custom grid
document.getElementById('createGrid').onclick = ()=>{
  const w = parseInt(prompt('Largura do grid (colunas):'),10);
  const h = parseInt(prompt('Altura do grid (linhas):'),10);
  if(!w || !h || w<=0 || h<=0) return alert('Valores inválidos');

  gridCols = w;
  gridRows = h;

  artCanvas.width = 640;
  artCanvas.height = Math.round(640 * (h / w));
  buffer.width = artCanvas.width;
  buffer.height = artCanvas.height;

  renderAll();
};

// seed colors
const seeds = ['#000000', '#141414', '#242424', '#333333','#424242', '#5c5c5c','#737373', '#8c8c8c', '#a3a3a3', '#bdbdbd', '#e0e0e0', '#2b3733',
               '#4a5451', '#6b7471','#8e9592', '#b2b7b5', 
               '#140700', '#1e1106', '#311b0c','#462510', '5c3011', '#733a13', '#8b4513','#a26238', '#b8805d','#cc9e83', '#e4a991',
               '#debeab', '#f1cbbc', '#b57d66','#8e6352', '#694a3e','#46322b', '#261d19', '#432422', '#592d2c', '#703735',
              '#6b2700', '#a33c00','#e05200', '#ff7221','#ff8742', '#241400','#573000', '#8f4f01','#d17b11', '#ff8c00','#ffa230', '#ffb357', ,'#ffc37a', '#ffd5a1', 
               '#1c1700', '#453a06','#705e00', '#9e8715', '#bf9f00', '#e3c21b','#ffd500', '#ffe042','#232400', '#5a5c00','#8a8c00', '#bcbf00','#9d9e42', '#bebf6f', 
              '#121a00','#2f3d0a', '#475919','#5c702a', '#90ab4d','#658c00', '#8bbf08','#60a302', '#315400','#102900', '#286300','#42a600', '#051c00','#105700', '#1c9600','#28db00', '#009405', 
              , '#0c4228','#0c6e3e', '#0eab5f','#10e880', '#3af098','#6af7b3', '#001c13', '#014d35', '#11664b', '#2c9473','#00ad76','#508f7b', '#82b8a7', '#024039', '#0f665c','#009c89', '#00c9b2','#00ffe1', '#75d1c6','#a8ede5', 
               '#00757d','#00a7b3', '#2ebfc9','#69cfd6', '#005273','#0082b5', '#1990bf','#00a6e8', '#35bdf2', '#000914', '#001938','#0a284d', '#00316e','#004dab', '#1a68c7','#4480c9', '#000926','#001454', '#152559','#000057', 
               '#000096','#0a0ad1', '#1a009e', '#1d144a','#362b70', '#574999','#897ec2', '#110033','#29007a', '#4000bf','#120021', '#300059','#53009c', '#7208cf','#2e0040', '#5f0085','#8415b0', '#b631eb','#ca57f7', '#d47cf7',
               '#de9ef7', '#e5b7f7','#e5b7f7', '#1c001b','#52004f', '#960091', '#cc02c5','#690050', '#b5008b','#1f0011', '#4d002b','#610d3c', '#8a014f','#ba026a', '#ff0090','#57001e', '#a10e42','#de0d56', 
              '#240000','#570000', '#800000','#ab0000', '#f20202','#521414', '#8f2222', '#d13232','#632d2d', '#964545','#c25555', '#ff7070','#db7d7d', '#ffa8a8','#a17777', '#f0bbbb', 
  '#1a0500', '#1a0900','#1a0e00', '#1a1200','#1a1700', '#161a00','#101a00', '#0a1a00','#001a01', '#001a08', '#001a0f', '#001a15','#00171a', '#00101a','#00081a', '#00011a','#06001a', '#0d001a','#14001a', '#1a0017', '#1a0011', '#1a000a','#1a0003'];
seeds.forEach(addColorToHistory);

// initial
renderAll(); undoStack.push(buffer.toDataURL()); updateUndoRedoButtons();
updateCurrentGridSize(); // Atualizar tamanho do grid no modal

// keyboard shortcuts: Z undo, X redo, E toggle eraser
window.addEventListener('keydown', (e)=>{
  if(e.key === 'z' || e.key === 'Z') undo();
  if(e.key === 'x' || e.key === 'X') redo();
  if(e.key === 'e' || e.key === 'E'){ currentColor = 'eraser'; document.getElementById('eraser').classList.add('activeTool'); }
});

// right-click paints with eraser (single cell)
artCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const pos = getPointerPos(e);
  pushUndo();
  const old = currentColor;
  currentColor = 'eraser';
  paintCellAt(pos.x, pos.y);
  currentColor = old;
});

// zoom: dblclick (PC) and double-tap (mobile) — mobile requires taps near same spot
let zoomed = false;
function toggleZoom(){ zoomed = !zoomed; if(zoomed){ artCanvas.style.transform = 'scale(2)'; artCanvas.style.transformOrigin = 'center center'; } else { artCanvas.style.transform = 'scale(1)'; } }
artCanvas.addEventListener('dblclick', ()=>{ toggleZoom(); });

let lastTapTime = 0; let lastTapX = 0; let lastTapY = 0;
artCanvas.addEventListener('touchend', (e)=>{
  const now = Date.now();
  const touch = e.changedTouches[0];
  const x = touch.clientX; const y = touch.clientY;
  const dt = now - lastTapTime; const dist = Math.hypot(x - lastTapX, y - lastTapY);
  if(dt < 300 && dist < 25) toggleZoom();
  lastTapTime = now; lastTapX = x; lastTapY = y;
});

// ==============================================
// TIMELINE FUNCTIONS - CORRIGIDAS
// ==============================================

function saveCurrentFrame() {
  if (frames[currentFrameIndex]) {
    const frameCanvas = document.createElement('canvas');
    frameCanvas.width = buffer.width;
    frameCanvas.height = buffer.height;
    const frameCtx = frameCanvas.getContext('2d');
    frameCtx.drawImage(buffer, 0, 0);
    frames[currentFrameIndex].imageData = frameCanvas.toDataURL();
  }
}

function loadFrame(index) {
  if (frames[index]) {
    const img = new Image();
    img.onload = () => {
      bctx.clearRect(0, 0, buffer.width, buffer.height);
      bctx.drawImage(img, 0, 0);
      renderAll();
    };
    img.src = frames[index].imageData;
    currentFrameIndex = index;
    updateFrameDisplay();
  }
}

function addFrame() {
  saveCurrentFrame();
  
  // CRIAR FRAME EM BRANCO (não copia o conteúdo atual)
  const frameCanvas = document.createElement('canvas');
  frameCanvas.width = buffer.width;
  frameCanvas.height = buffer.height;
  const frameCtx = frameCanvas.getContext('2d');
  
  // Limpar o canvas do novo frame (frame em branco)
  frameCtx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
  
  // Adicionar o frame em branco
  frames.push({
    imageData: frameCanvas.toDataURL(),
    duration: 250 // ms
  });
  
  currentFrameIndex = frames.length - 1;
  
  // Carregar o novo frame em branco
  loadFrame(currentFrameIndex);
  renderFrames();
  updateFrameDisplay();
}

function duplicateFrame() {
  if (frames.length === 0) return;
  
  saveCurrentFrame();
  
  // DUPLICAR realmente copia o frame atual
  const frameCanvas = document.createElement('canvas');
  frameCanvas.width = buffer.width;
  frameCanvas.height = buffer.height;
  const frameCtx = frameCanvas.getContext('2d');
  frameCtx.drawImage(buffer, 0, 0);
  
  frames.splice(currentFrameIndex + 1, 0, {
    imageData: frameCanvas.toDataURL(),
    duration: frames[currentFrameIndex].duration
  });
  
  currentFrameIndex++;
  loadFrame(currentFrameIndex);
  renderFrames();
  updateFrameDisplay();
}

function deleteFrame() {
  if (frames.length <= 1) return;
  
  frames.splice(currentFrameIndex, 1);
  
  if (currentFrameIndex >= frames.length) {
    currentFrameIndex = frames.length - 1;
  }
  
  loadFrame(currentFrameIndex);
  renderFrames();
  updateFrameDisplay();
}

function updateFrameDuration(index, change) {
  if (frames[index]) {
    let newDuration = frames[index].duration + change;
    // Limitar entre 50ms e 2000ms
    newDuration = Math.max(50, Math.min(2000, newDuration));
    frames[index].duration = newDuration;
    renderFrames();
  }
}

function renderFrames() {
  const container = document.getElementById('frames-container');
  container.innerHTML = '';
  
  frames.forEach((frame, index) => {
    const frameDiv = document.createElement('div');
    frameDiv.className = `frame ${index === currentFrameIndex ? 'active' : ''}`;
    frameDiv.onclick = () => {
      saveCurrentFrame();
      loadFrame(index);
    };
    
    const frameNumber = document.createElement('div');
    frameNumber.className = 'frame-number';
    frameNumber.textContent = index + 1;
    
    const frameCanvas = document.createElement('canvas');
    frameCanvas.width = 80;
    frameCanvas.height = 80;
    const frameCtx = frameCanvas.getContext('2d');
    
    const img = new Image();
    img.onload = () => {
      frameCtx.drawImage(img, 0, 0, 80, 80);
    };
    img.src = frame.imageData;
    
    const frameDuration = document.createElement('div');
    frameDuration.className = 'frame-duration';
    frameDuration.textContent = `${frame.duration}ms`;
    
    // Controles de duração
    const durationControls = document.createElement('div');
    durationControls.className = 'frame-duration-controls';
    
    const minusBtn = document.createElement('button');
    minusBtn.className = 'duration-btn';
    minusBtn.innerHTML = '-';
    minusBtn.onclick = (e) => {
      e.stopPropagation();
      updateFrameDuration(index, -50);
    };
    
    const plusBtn = document.createElement('button');
    plusBtn.className = 'duration-btn';
    plusBtn.innerHTML = '+';
    plusBtn.onclick = (e) => {
      e.stopPropagation();
      updateFrameDuration(index, 50);
    };
    
    durationControls.appendChild(minusBtn);
    durationControls.appendChild(plusBtn);
    
    const frameActions = document.createElement('div');
    frameActions.className = 'frame-actions';
    
    const upBtn = document.createElement('button');
    upBtn.className = 'frame-btn';
    upBtn.innerHTML = '↑';
    upBtn.onclick = (e) => {
      e.stopPropagation();
      if (index > 0) {
        [frames[index], frames[index - 1]] = [frames[index - 1], frames[index]];
        currentFrameIndex = index - 1;
        renderFrames();
        updateFrameDisplay();
      }
    };
    
    const downBtn = document.createElement('button');
    downBtn.className = 'frame-btn';
    downBtn.innerHTML = '↓';
    downBtn.onclick = (e) => {
      e.stopPropagation();
      if (index < frames.length - 1) {
        [frames[index], frames[index + 1]] = [frames[index + 1], frames[index]];
        currentFrameIndex = index + 1;
        renderFrames();
        updateFrameDisplay();
      }
    };
    
    frameActions.appendChild(upBtn);
    frameActions.appendChild(downBtn);
    
    frameDiv.appendChild(frameNumber);
    frameDiv.appendChild(frameCanvas);
    frameDiv.appendChild(frameDuration);
    frameDiv.appendChild(durationControls);
    frameDiv.appendChild(frameActions);
    container.appendChild(frameDiv);
  });
}

function updateFrameDisplay() {
  document.querySelectorAll('.frame').forEach((frame, index) => {
    frame.classList.toggle('active', index === currentFrameIndex);
  });
  document.getElementById('frame-counter').textContent = `Frame: ${currentFrameIndex + 1}/${frames.length}`;
}

function previewAnimation() {
  const previewContainer = document.getElementById('animation-preview');
  const previewCanvas = document.getElementById('preview-canvas');
  const previewCtx = previewCanvas.getContext('2d');
  const frameCounter = document.getElementById('frame-counter');
  const playPauseBtn = document.getElementById('playPause');
  const playbackSpeed = document.getElementById('playback-speed');
  
  previewContainer.style.display = 'flex';
  
  if (frames.length === 0) {
    alert('Adicione pelo menos um frame para visualizar a animação!');
    return;
  }
  
  let previewFrameIndex = 0;
  
  function drawPreviewFrame() {
    if (frames[previewFrameIndex]) {
      const img = new Image();
      img.onload = () => {
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
        frameCounter.textContent = `Frame: ${previewFrameIndex + 1}/${frames.length}`;
      };
      img.src = frames[previewFrameIndex].imageData;
    }
  }
  
  function playAnimation() {
    if (isPlaying) return;
    
    isPlaying = true;
    playPauseBtn.textContent = '⏸ Pause';
    
    let speed;
    if (playbackSpeed.value === 'custom') {
      speed = parseInt(document.getElementById('custom-speed-input').value);
    } else {
      speed = parseInt(playbackSpeed.value);
    }
    
    playInterval = setInterval(() => {
      previewFrameIndex = (previewFrameIndex + 1) % frames.length;
      drawPreviewFrame();
    }, speed);
  }
  
  function pauseAnimation() {
    if (!isPlaying) return;
    
    isPlaying = false;
    playPauseBtn.textContent = '▶ Play';
    clearInterval(playInterval);
  }
  
  function stopAnimation() {
    isPlaying = false;
    playPauseBtn.textContent = '▶ Play';
    clearInterval(playInterval);
    previewFrameIndex = 0;
    drawPreviewFrame();
  }
  
  playPauseBtn.onclick = () => {
    if (isPlaying) {
      pauseAnimation();
    } else {
      playAnimation();
    }
  };
  
  document.getElementById('stopPreview').onclick = stopAnimation;
  
  playbackSpeed.onchange = () => {
    if (isPlaying) {
      pauseAnimation();
      playAnimation();
    }
  };
  
  drawPreviewFrame();
}

function exportGIF() {
  if (frames.length === 0) {
    alert('Adicione pelo menos um frame para exportar como GIF!');
    return;
  }
  
  alert('Exportar GIF - Esta funcionalidade requer uma biblioteca externa como gif.js. Para implementação completa, adicione a biblioteca gif.js ao projeto.');
}

// Aplicar velocidade customizada ao frame atual
document.getElementById('apply-custom-speed').onclick = () => {
  const customSpeed = parseInt(document.getElementById('custom-speed-input').value);
  if (isNaN(customSpeed) || customSpeed < 50 || customSpeed > 2000) {
    alert('Por favor, insira um valor entre 50 e 2000 ms');
    return;
  }
  
  if (frames[currentFrameIndex]) {
    frames[currentFrameIndex].duration = customSpeed;
    renderFrames();
    alert(`Velocidade do frame ${currentFrameIndex + 1} atualizada para ${customSpeed}ms`);
  }
};

// Aplicar velocidade customizada a todos os frames
document.getElementById('apply-all-speed').onclick = () => {
  const customSpeed = parseInt(document.getElementById('custom-speed-input').value);
  if (isNaN(customSpeed) || customSpeed < 50 || customSpeed > 2000) {
    alert('Por favor, insira um valor entre 50 e 2000 ms');
    return;
  }
  
  frames.forEach(frame => {
    frame.duration = customSpeed;
  });
  
  renderFrames();
  alert(`Velocidade de todos os frames atualizada para ${customSpeed}ms`);
};

// Event listeners for timeline controls
document.getElementById('addFrame').onclick = addFrame;
document.getElementById('duplicateFrame').onclick = duplicateFrame;
document.getElementById('deleteFrame').onclick = deleteFrame;
document.getElementById('previewAnimation').onclick = previewAnimation;
document.getElementById('exportGIF').onclick = exportGIF;

// Add initial frame (frame em branco)
addFrame();
  
  

</script>
</body>
</html>
