


<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Art Studio</title>
  <style>
:root{
  --bg:#1e1e1e;
  --panel:#2a2a2a;
  --panel-dark:#1f1f1f;
  --border:#3a3a3a;
  --accent:#7a5cff;
  --text:#e6e6e6;
  --muted:#a0a0a0;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:linear-gradient(180deg,#1b1b1b,#111);
  font-family:Arial, Helvetica, sans-serif;
  display:flex;
  height:180vh;
  color:var(--text);
}
#toolbar{
  width:260px;
  background:var(--panel-dark);
  border-right:2px solid var(--border);
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:14px;
}
#toolbar h1{
  margin:0 0 6px 0;
  text-align:center;
  font-size:18px;
  letter-spacing:1px;
}
.toolbox-group{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:8px;
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.toolbox-group h4{
  margin:0;
  font-size:11px;
  color:var(--muted);
  letter-spacing:1px;
}
.toolbox-row{
  display:flex;
  gap:6px;
  flex-wrap:wrap;
}
button,select,input{
  background:#202020;
  border:1px solid var(--border);
  color:var(--text);
  padding:6px 8px;
  border-radius:6px;
  font-size:13px;
  cursor:pointer;
}
button:hover{background:#2c2c2c}
button.activeTool{background:var(--accent);border-color:#000}
.layer-item{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px 8px;
  border:1px solid var(--border);
  border-radius:6px;
  background:#222;
  cursor:pointer;
  font-size:13px;
}
.layer-item.active-layer{
  background:var(--accent);
}
.color-btn{
  width:26px;
  height:26px;
  border:1px solid #000;
  cursor:pointer;
}
.color-btn.selected{outline:2px solid var(--accent)}
#grid{
  background:#fff;
  image-rendering:pixelated;
  cursor:crosshair;
}
#colorHistory{
  display:flex;
  flex-wrap:wrap;
  gap:4px;
  padding:6px;
}
.main{
  flex:1;
  display:flex;
  justify-content:center;
  align-items:center;
}
</style>
</head>
<body>

<div id="toolbar">

  <h1 style="font-size:18px;margin:0 0 8px 0;text-align:center;">Pixel Art Studio</h1>

  <div class="toolbox-group">
    <h4>Arquivo</h4>
    <div class="toolbox-row">
      <button id="newArt"><span class="btn-icon">üóé</span>Nova Arte</button>
      <button id="download"><span class="btn-icon">‚¨á</span>Download</button>
    </div>
  </div>

  <div class="toolbox-group">
    <h4>Editar</h4>
    <div class="toolbox-row">
      <button id="undoBtn"><span class="btn-icon">‚Ü∂</span>Desfazer</button>
      <button id="redoBtn"><span class="btn-icon">‚Ü∑</span>Refazer</button>
      <button id="eraser"><span class="btn-icon">‚ñ¢</span>Borracha</button>
    </div>
  </div>

  <div class="toolbox-group">
    <h4>Grid</h4>
    <div class="toolbox-row">
      <button id="toggleGrid" class="activeTool"><span class="btn-icon">‚ñ¶</span>Grid</button>
      <button id="toggleExportGrid" class="activeTool"><span class="btn-icon">‚ñ§</span>Export</button>
    </div>
    <div class="toolbox-row">
      <select id="gridSize">
        <option value="16">16√ó16</option>
        <option value="32">32√ó32</option>
        <option value="64" selected>64√ó64</option>
        <option value="128">128√ó128</option>
        <option value="256">256√ó256</option>
      </select>
      <button id="createGrid"><span class="btn-icon">‚úö</span>Grid</button>
    </div>
  </div>

  <div class="toolbox-group" id="layersPanel">
    <h4>Layers</h4>
    <div class="toolbox-row" style="flex-direction:column; gap:4px;">
      <div class="layer-item active-layer">üü¶ Layer 1</div>
    </div>
    <div class="toolbox-row">
      <button id="addLayer"><span class="btn-icon">Ôºã</span></button>
      <button id="removeLayer"><span class="btn-icon">Ôºç</span></button>
    </div>
  </div>


  <div class="toolbox-group">
    <h4>Cores</h4>
    <div class="toolbox-row">
      <input type="text" id="customColor" placeholder="#hex" />
      <button id="addColor"><span class="btn-icon">üé®</span>Cor</button>
    </div>
  </div>

</div>

<div style="flex:1; display:flex; flex-direction:column; align-items:center; padding:20px;">
<canvas id="grid" width="640" height="640"></canvas>

<h3>Hist√≥rico de Cores</h3>
<div id="colorHistory"></div>

<script>
// --- setup ---
const artCanvas = document.getElementById('grid');
const ctx = artCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// offscreen buffer that stores pixel artwork (without grid)
const buffer = document.createElement('canvas');
const bctx = buffer.getContext('2d');
buffer.width = artCanvas.width;
buffer.height = artCanvas.height;

// state
let size = 64; // backward compatibility (square)
let gridCols = 64;
let gridRows = 64;
let cell = artCanvas.width / size;
let currentColor = '#000000';
let colorHistory = [];
let isDrawing = false;
let showGrid = true; // grid de visualiza√ß√£o
let includeGridOnExport = true; // grid no download

// undo/redo (store buffer dataURLs)
const undoStack = [];
const redoStack = [];

function pushUndo(){
  try{
    undoStack.push(buffer.toDataURL());
    if(undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
  }catch(e){console.warn('save failed',e);} 
}

function restoreBuffer(dataURL, callback){
  const img = new Image();
  img.onload = () => {
    bctx.clearRect(0,0,buffer.width,buffer.height);
    bctx.drawImage(img,0,0);
    renderAll();
    if(callback) callback();
  };
  img.src = dataURL;
}

function undo(){ if(undoStack.length===0) return; redoStack.push(buffer.toDataURL()); const last = undoStack.pop(); restoreBuffer(last); updateUndoRedoButtons(); }
function redo(){ if(redoStack.length===0) return; undoStack.push(buffer.toDataURL()); const next = redoStack.pop(); restoreBuffer(next); updateUndoRedoButtons(); }
function updateUndoRedoButtons(){ document.getElementById('undoBtn').disabled = undoStack.length===0; document.getElementById('redoBtn').disabled = redoStack.length===0; }

// draw grid path once per render to avoid double-stroke at intersections
function drawGridOnContext(targetCtx){
  const path = new Path2D();
  const cw = targetCtx === ctx ? artCanvas.width : buffer.width;
  const ch = targetCtx === ctx ? artCanvas.height : buffer.height;

  const stepX = cw / gridCols;
  const stepY = ch / gridRows;

  targetCtx.lineWidth = 0.7; // grid mais vis√≠vel
  targetCtx.strokeStyle = '#8a8a8a';

  // linhas verticais
  for(let i = 0; i <= gridCols; i++){
    const x = Math.round(i * stepX) + 0.5;
    path.moveTo(x, 0);
    path.lineTo(x, ch);
  }

  // linhas horizontais
  for(let j = 0; j <= gridRows; j++){
    const y = Math.round(j * stepY) + 0.5;
    path.moveTo(0, y);
    path.lineTo(cw, y);
  }

  targetCtx.stroke(path);

  // contorno final (direita e embaixo garantidos)
  targetCtx.strokeRect(0.5, 0.5, cw - 1, ch - 1);
}

// render: draw buffer (pixels) then grid on top
function renderAll(){
  ctx.clearRect(0,0,artCanvas.width,artCanvas.height);
  ctx.drawImage(buffer, 0, 0);
  if(showGrid){
    drawGridOnContext(ctx);
  }
}

function resizeBufferToCanvas(){ buffer.width = artCanvas.width; buffer.height = artCanvas.height; }

function paintCellAt(xPixel, yPixel){
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;

  const x = Math.floor(xPixel / stepX);
  const y = Math.floor(yPixel / stepY);
  if(x < 0 || y < 0 || x >= gridCols || y >= gridRows) return;

  const px = Math.round(x * stepX);
  const py = Math.round(y * stepY);
  const w = Math.ceil(stepX);
  const h = Math.ceil(stepY);

  bctx.imageSmoothingEnabled = false;
  bctx.fillStyle = (currentColor === 'eraser') ? 'white' : currentColor;
  bctx.fillRect(px, py, w, h);

  renderAll();
}

function getPointerPos(evt){
  const rect = artCanvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const xCss = clientX - rect.left;
  const yCss = clientY - rect.top;
  const scaleX = artCanvas.width / rect.width;
  const scaleY = artCanvas.height / rect.height;
  return { x: xCss * scaleX, y: yCss * scaleY };
}

// events
artCanvas.addEventListener('pointerdown', (e)=>{
  // left button only (button === 0)
  if(e.button !== undefined && e.button !== 0) return;
  pushUndo(); // save state before edit
  isDrawing = true;
  const pos = getPointerPos(e);
  paintCellAt(pos.x, pos.y);
  e.preventDefault();
});
window.addEventListener('pointerup', ()=>{ isDrawing = false; });
artCanvas.addEventListener('pointermove', (e)=>{ if(!isDrawing) return; const pos = getPointerPos(e); paintCellAt(pos.x, pos.y); e.preventDefault(); });

// toolbar actions
document.getElementById('newArt').onclick = ()=>{ pushUndo(); bctx.clearRect(0,0,buffer.width,buffer.height); renderAll(); };
document.getElementById('gridSize').onchange = (e)=>{
  const v = parseInt(e.target.value,10)||64;
  gridCols = v;
  gridRows = v;
  renderAll();
};

// download (respeita op√ß√£o de grid no download)
document.getElementById('download').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // fundo branco
  tctx.fillStyle = "white";
  tctx.fillRect(0, 0, tmp.width, tmp.height);

  // arte
  tctx.drawImage(buffer,0,0);

  // grid opcional no export
  if(includeGridOnExport){
    drawGridOnContext(tctx);
  }

  const link = document.createElement('a');
  link.download = 'pixel_art.png';
  link.href = tmp.toDataURL();
  link.click();
};

// eraser button toggle
const eraserBtn = document.getElementById('eraser');
eraserBtn.onclick = ()=>{ currentColor = (currentColor === 'eraser') ? '#000000' : 'eraser'; eraserBtn.classList.toggle('activeTool', currentColor === 'eraser'); };

// grid toggle (visualiza√ß√£o)
const toggleGridBtn = document.getElementById('toggleGrid');
toggleGridBtn.onclick = ()=>{
  showGrid = !showGrid;
  toggleGridBtn.textContent = showGrid ? 'Grid ON' : 'Grid OFF';
  toggleGridBtn.classList.toggle('activeTool', showGrid);
  renderAll();
};

// grid no download toggle
const toggleExportGridBtn = document.getElementById('toggleExportGrid');
toggleExportGridBtn.onclick = ()=>{
  includeGridOnExport = !includeGridOnExport;
  toggleExportGridBtn.textContent = includeGridOnExport ? 'Grid no Download' : 'Sem Grid no Download';
  toggleExportGridBtn.classList.toggle('activeTool', includeGridOnExport);
};

// undo/redo buttons
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// color history
function addColorToHistory(hex){ if(!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)) return; if(!colorHistory.includes(hex)){ colorHistory.push(hex); const div = document.getElementById('colorHistory'); const btn = document.createElement('div'); btn.className='color-btn'; btn.style.background=hex; btn.title=hex; btn.onclick = ()=>{
        currentColor = hex;
        eraserBtn.classList.remove('activeTool');
        document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected'));
        btn.classList.add('selected');
      }; div.appendChild(btn); } }

document.getElementById('addColor').onclick = ()=>{ const hex = document.getElementById('customColor').value.trim(); if(/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)){ addColorToHistory(hex); currentColor = hex; eraserBtn.classList.remove('activeTool'); document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected')); const last = document.querySelector('#colorHistory .color-btn:last-child'); if(last) last.classList.add('selected'); } else alert('HEX inv√°lido. Use #fff ou #1a2b3c'); };

// create custom grid
document.getElementById('createGrid').onclick = ()=>{
  const w = parseInt(prompt('Largura do grid (colunas):'),10);
  const h = parseInt(prompt('Altura do grid (linhas):'),10);
  if(!w || !h || w<=0 || h<=0) return alert('Valores inv√°lidos');

  gridCols = w;
  gridRows = h;

  artCanvas.width = 640;
  artCanvas.height = Math.round(640 * (h / w));
  buffer.width = artCanvas.width;
  buffer.height = artCanvas.height;

  renderAll();
};

// seed colors
const seeds = ['#000000', '#141414', '#242424', '#333333','#424242', '#5c5c5c','#737373', '#8c8c8c', '#a3a3a3', '#bdbdbd', '#e0e0e0', '#2b3733',
               '#4a5451', '#6b7471','#8e9592', '#b2b7b5', 
               '#140700', '#1e1106', '#311b0c','#462510', '5c3011', '#733a13', '#8b4513','#a26238', '#b8805d','#cc9e83', '#e4a991',
               '#debeab', '#f1cbbc', '#b57d66','#8e6352', '#694a3e','#46322b', '#261d19', '#432422', '#592d2c', '#703735',
              '#6b2700', '#a33c00','#e05200', '#ff7221','#ff8742', '#241400','#573000', '#8f4f01','#d17b11', '#ff8c00','#ffa230', '#ffb357', ,'#ffc37a', '#ffd5a1', 
               '#1c1700', '#453a06','#705e00', '#9e8715', '#bf9f00', '#e3c21b','#ffd500', '#ffe042','#232400', '#5a5c00','#8a8c00', '#bcbf00','#9d9e42', '#bebf6f', 
              '#121a00','#2f3d0a', '#475919','#5c702a', '#90ab4d','#658c00', '#8bbf08','#60a302', '#315400','#102900', '#286300','#42a600', '#051c00','#105700', '#1c9600','#28db00', '#009405', 
              , '#0c4228','#0c6e3e', '#0eab5f','#10e880', '#3af098','#6af7b3', '#001c13', '#014d35', '#11664b', '#2c9473','#00ad76','#508f7b', '#82b8a7', '#024039', '#0f665c','#009c89', '#00c9b2','#00ffe1', '#75d1c6','#a8ede5', 
               '#00757d','#00a7b3', '#2ebfc9','#69cfd6', '#005273','#0082b5', '#1990bf','#00a6e8', '#35bdf2', '#000914', '#001938','#0a284d', '#00316e','#004dab', '#1a68c7','#4480c9', '#000926','#001454', '#152559','#000057', 
               '#000096','#0a0ad1', '#1a009e', '#1d144a','#362b70', '#574999','#897ec2', '#110033','#29007a', '#4000bf','#120021', '#300059','#53009c', '#7208cf','#2e0040', '#5f0085','#8415b0', '#b631eb','#ca57f7', '#d47cf7',
               '#de9ef7', '#e5b7f7','#e5b7f7', '#1c001b','#52004f', '#960091', '#cc02c5','#690050', '#b5008b','#1f0011', '#4d002b','#610d3c', '#8a014f','#ba026a', '#ff0090','#57001e', '#a10e42','#de0d56', 
              '#240000','#570000', '#800000','#ab0000', '#f20202','#521414', '#8f2222', '#d13232','#632d2d', '#964545','#c25555', '#ff7070','#db7d7d', '#ffa8a8','#a17777', '#f0bbbb', 
  '#1a0500', '#1a0900','#1a0e00', '#1a1200','#1a1700', '#161a00','#101a00', '#0a1a00','#001a01', '#001a08', '#001a0f', '#001a15','#00171a', '#00101a','#00081a', '#00011a','#06001a', '#0d001a','#14001a', '#1a0017', '#1a0011', '#1a000a','#1a0003'];
seeds.forEach(addColorToHistory);

// initial
renderAll(); undoStack.push(buffer.toDataURL()); updateUndoRedoButtons();

// keyboard shortcuts: Z undo, X redo, E toggle eraser
window.addEventListener('keydown', (e)=>{
  if(e.key === 'z' || e.key === 'Z') undo();
  if(e.key === 'x' || e.key === 'X') redo();
  if(e.key === 'e' || e.key === 'E'){ currentColor = 'eraser'; document.getElementById('eraser').classList.add('activeTool'); }
});

// right-click paints with eraser (single cell)
artCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const pos = getPointerPos(e);
  pushUndo();
  const old = currentColor;
  currentColor = 'eraser';
  paintCellAt(pos.x, pos.y);
  currentColor = old;
});

// zoom: dblclick (PC) and double-tap (mobile) ‚Äî mobile requires taps near same spot
let zoomed = false;
function toggleZoom(){ zoomed = !zoomed; if(zoomed){ artCanvas.style.transform = 'scale(2)'; artCanvas.style.transformOrigin = 'center center'; } else { artCanvas.style.transform = 'scale(1)'; } }
artCanvas.addEventListener('dblclick', ()=>{ toggleZoom(); });

let lastTapTime = 0; let lastTapX = 0; let lastTapY = 0;
artCanvas.addEventListener('touchend', (e)=>{
  const now = Date.now();
  const touch = e.changedTouches[0];
  const x = touch.clientX; const y = touch.clientY;
  const dt = now - lastTapTime; const dist = Math.hypot(x - lastTapX, y - lastTapY);
  if(dt < 300 && dist < 25) toggleZoom();
  lastTapTime = now; lastTapX = x; lastTapY = y;
});

</script>
</body>
</html>
