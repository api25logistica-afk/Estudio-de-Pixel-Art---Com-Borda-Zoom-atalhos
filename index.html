<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Art Studio</title>
  <style>
    body{ margin:0; background:#f5f5f5; font-family:Arial, Helvetica, sans-serif; display:flex; flex-direction:column; align-items:center; padding:20px; }
    #toolbar{ display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; align-items:center; }
    button, select, input{ padding:6px 8px; font-size:14px; }
    .color-btn{ width:28px; height:28px; border:1px solid #000; cursor:pointer; box-sizing:border-box; display:inline-block; }
    #grid{ background:white; border:none; image-rendering:pixelated; cursor:crosshair; touch-action:none; width:640px; height:640px; }
    #colorHistory{ display:flex; flex-wrap:wrap; gap:5px; margin-top:10px; max-width:640px; max-height:160px; overflow:auto; padding:5px; background:transparent; }
    #colorHistory .color-btn{ flex:0 0 calc((640px - 19*5px) / 20); }
    #colorHistory::-webkit-scrollbar{ height:10px; width:10px; }
    #colorHistory::-webkit-scrollbar-thumb{ background:#888; border-radius:4px; }
    #colorHistory::-webkit-scrollbar-track{ background:#e0e0e0; }
    #customColor{ width:90px; }
    .activeTool{ outline:3px solid rgba(0,0,0,0.08); }
  </style>
</head>
<body>

<h1>Pixel Art Studio</h1>

<div id="toolbar">
  <button id="createGrid">Criar Grid</button>
  <button id="newArt">Nova Arte</button>
  <button id="undoBtn">Desfazer</button>
  <button id="redoBtn">Refazer</button>
  <button id="download">Download</button>
  <button id="eraser">Borracha</button>

  <label for="gridSize">Grid:</label>
  <select id="gridSize">
    <option value="16">16 x 16</option>
    <option value="32">32 x 32</option>
    <option value="64" selected>64 x 64</option>
    <option value="128">128 x 128</option>
    <option value="256">256 x 256</option>
  </select>

  <input type="text" id="customColor" placeholder="#hex" />
  <button id="addColor">Criar Cor</button>
</div>

<canvas id="grid" width="640" height="640"></canvas>

<h3>Histórico de Cores</h3>
<div id="colorHistory"></div>

<script>
// --- setup ---
const artCanvas = document.getElementById('grid');
const ctx = artCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// offscreen buffer that stores pixel artwork (without grid)
const buffer = document.createElement('canvas');
const bctx = buffer.getContext('2d');
buffer.width = artCanvas.width;
buffer.height = artCanvas.height;

// state
let size = 64; // cells per side
let cell = artCanvas.width / size;
let currentColor = '#000000';
let colorHistory = [];
let isDrawing = false;

// undo/redo (store buffer dataURLs)
const undoStack = [];
const redoStack = [];

function pushUndo(){
  try{
    undoStack.push(buffer.toDataURL());
    if(undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
  }catch(e){console.warn('save failed',e);} 
}

function restoreBuffer(dataURL, callback){
  const img = new Image();
  img.onload = () => {
    bctx.clearRect(0,0,buffer.width,buffer.height);
    bctx.drawImage(img,0,0);
    renderAll();
    if(callback) callback();
  };
  img.src = dataURL;
}

function undo(){ if(undoStack.length===0) return; redoStack.push(buffer.toDataURL()); const last = undoStack.pop(); restoreBuffer(last); updateUndoRedoButtons(); }
function redo(){ if(redoStack.length===0) return; undoStack.push(buffer.toDataURL()); const next = redoStack.pop(); restoreBuffer(next); updateUndoRedoButtons(); }
function updateUndoRedoButtons(){ document.getElementById('undoBtn').disabled = undoStack.length===0; document.getElementById('redoBtn').disabled = redoStack.length===0; }

// draw grid path once per render to avoid double-stroke at intersections
function drawGridOnContext(targetCtx){
  const path = new Path2D();
  const half = 0.5;
  const cw = targetCtx === ctx ? artCanvas.width : buffer.width;
  const ch = targetCtx === ctx ? artCanvas.height : buffer.height;
  const localCell = cell; // cell is same for buffer and canvas (bitmap size)
  targetCtx.lineWidth = 0.7;
  targetCtx.strokeStyle = '#a3a0a0';
  for(let i=0;i<=size;i++){
    const x = Math.round(i * localCell) + half;
    path.moveTo(x,0); path.lineTo(x,ch);
  }
  for(let j=0;j<=size;j++){
    const y = Math.round(j * localCell) + half;
    path.moveTo(0,y); path.lineTo(cw,y);
  }
  targetCtx.stroke(path);
}

// render: draw buffer (pixels) then grid on top
function renderAll(){
  // clear main ctx
  ctx.clearRect(0,0,artCanvas.width,artCanvas.height);
  // draw buffer (scaled 1:1)
  ctx.drawImage(buffer, 0, 0);
  // draw grid lines on top (single path)
  drawGridOnContext(ctx);
}

function resizeBufferToCanvas(){ buffer.width = artCanvas.width; buffer.height = artCanvas.height; }

function paintCellAt(xPixel, yPixel){
  const x = Math.floor(xPixel / cell);
  const y = Math.floor(yPixel / cell);
  if(x<0||y<0||x>=size||y>=size) return;
  const px = Math.floor(x*cell);
  const py = Math.floor(y*cell);
  bctx.fillStyle = (currentColor === 'eraser') ? 'white' : currentColor;
  bctx.fillRect(px, py, Math.ceil(cell), Math.ceil(cell));
  renderAll();
}

function getPointerPos(evt){
  const rect = artCanvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const xCss = clientX - rect.left;
  const yCss = clientY - rect.top;
  const scaleX = artCanvas.width / rect.width;
  const scaleY = artCanvas.height / rect.height;
  return { x: xCss * scaleX, y: yCss * scaleY };
}

// events
artCanvas.addEventListener('pointerdown', (e)=>{
  // left button only (button === 0)
  if(e.button !== undefined && e.button !== 0) return;
  pushUndo(); // save state before edit
  isDrawing = true;
  const pos = getPointerPos(e);
  paintCellAt(pos.x, pos.y);
  e.preventDefault();
});
window.addEventListener('pointerup', ()=>{ isDrawing = false; });
artCanvas.addEventListener('pointermove', (e)=>{ if(!isDrawing) return; const pos = getPointerPos(e); paintCellAt(pos.x, pos.y); e.preventDefault(); });

// toolbar actions
document.getElementById('newArt').onclick = ()=>{ pushUndo(); bctx.clearRect(0,0,buffer.width,buffer.height); renderAll(); };
document.getElementById('gridSize').onchange = (e)=>{ size = parseInt(e.target.value,10)||64; cell = artCanvas.width/size; renderAll(); };

// download (renders current buffer + grid)
document.getElementById('download').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // fundo branco
  tctx.fillStyle = "white";
  tctx.fillRect(0, 0, tmp.width, tmp.height);

  // arte + grid
  tctx.drawImage(buffer,0,0);
  drawGridOnContext(tctx);

  const link = document.createElement('a');
  link.download = 'pixel_art.png';
  link.href = tmp.toDataURL();
  link.click();
};

// eraser button toggle
const eraserBtn = document.getElementById('eraser');
eraserBtn.onclick = ()=>{ currentColor = (currentColor === 'eraser') ? '#000000' : 'eraser'; eraserBtn.classList.toggle('activeTool', currentColor === 'eraser'); };

// undo/redo buttons
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// color history
function addColorToHistory(hex){ if(!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)) return; if(!colorHistory.includes(hex)){ colorHistory.push(hex); const div = document.getElementById('colorHistory'); const btn = document.createElement('div'); btn.className='color-btn'; btn.style.background=hex; btn.title=hex; btn.onclick = ()=>{ currentColor = hex; eraserBtn.classList.remove('activeTool'); }; div.appendChild(btn); } }

document.getElementById('addColor').onclick = ()=>{ const hex = document.getElementById('customColor').value.trim(); if(/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)){ addColorToHistory(hex); currentColor = hex; eraserBtn.classList.remove('activeTool'); } else alert('HEX inválido. Use #fff ou #1a2b3c'); };

// create custom grid
document.getElementById('createGrid').onclick = ()=>{ const w = parseInt(prompt('Largura do grid (ex: 64):'),10); const h = parseInt(prompt('Altura do grid (ex: 64):'),10); if(!w || !h || w<=0 || h<=0) return alert('Valores inválidos'); size = w; artCanvas.width = 640; artCanvas.height = Math.round(640 * (h / w)); buffer.width = artCanvas.width; buffer.height = artCanvas.height; cell = artCanvas.width / size; renderAll(); };

// seed colors
const seeds = ['#000000','#1a1a1a','#303030','#4a4a4a','#6e6e6e','#919191','#b5b5b5','#c7c6c5','#1f1204','#341d08','#4b280a','#633309','#7c3f06','#964b00','#ac6730','#c08457','#d3a27f','#cfb99e','#e4c0a8','#dbcab5','#c95d00','#ff7600','#ff8924','#ff9840','#ffb300','#ffcc00','#ffe682','#bec300','#b0b600','#a2a900','#adac40','#9d9a4d','#8c8958','#7b7860','#24230f','#183800','#2d6900','#45a100','#63e800','#96f74f','#21bd13','#00ff3c','#30ff61','#61ff86','#9bfab1','#0b8f2a','#17a362','#0eed9f','#047d53','#4ef5ba','#74f7c9','#a9fcdf','#00ffc8','#09756e','#02bfb3','#02aec4','#0c7b8a','#014852','#009fde','#0080ff','#025cb5','#0036a1','#001eb3','#000587','#000240','#5900ff','#471a9c','#1d0054','#281352','#513885','#bfa1ff','#8800ff','#8a6ec4','#b700ff','#cd4fff','#e091ff','#e600ff','#631c6b','#ad1081','#700f55','#2b0320','#ff0066','#a30242','#4d0521','#ad0026','#ff0038','#ff0015','#ab000e','#630008','#300004','#782229','#c24e57','#ff8089','#ffb3b8', '#ffffff', '#465c4d'];
seeds.forEach(addColorToHistory);

// initial
renderAll(); undoStack.push(buffer.toDataURL()); updateUndoRedoButtons();

// keyboard shortcuts: Z undo, X redo, E toggle eraser
window.addEventListener('keydown', (e)=>{
  if(e.key === 'z' || e.key === 'Z') undo();
  if(e.key === 'x' || e.key === 'X') redo();
  if(e.key === 'e' || e.key === 'E'){ currentColor = 'eraser'; document.getElementById('eraser').classList.add('activeTool'); }
});

// right-click paints with eraser (single cell)
artCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const pos = getPointerPos(e);
  pushUndo();
  const old = currentColor;
  currentColor = 'eraser';
  paintCellAt(pos.x, pos.y);
  currentColor = old;
});

// zoom: dblclick (PC) and double-tap (mobile) — mobile requires taps near same spot
let zoomed = false;
function toggleZoom(){ zoomed = !zoomed; if(zoomed){ artCanvas.style.transform = 'scale(2)'; artCanvas.style.transformOrigin = 'center center'; } else { artCanvas.style.transform = 'scale(1)'; } }
artCanvas.addEventListener('dblclick', ()=>{ toggleZoom(); });

let lastTapTime = 0; let lastTapX = 0; let lastTapY = 0;
artCanvas.addEventListener('touchend', (e)=>{
  const now = Date.now();
  const touch = e.changedTouches[0];
  const x = touch.clientX; const y = touch.clientY;
  const dt = now - lastTapTime; const dist = Math.hypot(x - lastTapX, y - lastTapY);
  if(dt < 300 && dist < 25) toggleZoom();
  lastTapTime = now; lastTapX = x; lastTapY = y;
});

</script>
</body>
</html>
