<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Art Studio</title>
  <style>
    :root{
      --bg:#0b0e14;
      --panel:#121826;
      --panel-2:#0f172a;
      --border:#1f2937;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#8b5cf6;
      --accent-hover:#7c3aed;
      --danger:#ef4444;
      --grid:#374151;
      --selection:#3b82f6;
    }
    body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial, Helvetica, sans-serif; display:flex; flex-direction:column; align-items:center; padding:20px; }
    h1,h3,h4{ color:var(--text); }
    #toolbar{ display:flex; gap:16px; margin-bottom:14px; flex-wrap:wrap; align-items:flex-start; background:var(--panel); padding:12px; border-radius:12px; box-shadow:0 10px 25px rgba(0,0,0,.35); border:1px solid var(--border); }
    .toolbox-group{ display:flex; flex-direction:column; gap:8px; background:var(--panel-2); padding:10px; border-radius:10px; box-shadow: inset 0 0 0 1px var(--border); }
    .toolbox-group h4{ margin:0 0 6px 0; font-size:12px; letter-spacing:1px; text-transform:uppercase; color:var(--muted); }
    .toolbox-row{ display:flex; gap:6px; flex-wrap:wrap; }
    .toolbox-subrow{ display:flex; flex-direction:column; gap:6px; width:100%; }
    button, select, input{ padding:6px 10px; font-size:14px; border-radius:8px; border:1px solid var(--border); background:#0b1220; color:var(--text); cursor:pointer; }
    button:hover, select:hover, input:hover{ background:#111827; }
    button.activeTool{ background:var(--accent); border-color:var(--accent); color:white; }
    select option{ background:#0b1220; color:var(--text); }
    .color-btn{ width:28px; height:28px; border:1px solid #000; cursor:pointer; box-sizing:border-box; display:inline-block; border-radius:6px; }
    .color-btn.selected{ outline:3px solid var(--accent); }
    #grid{ background:white; border-radius:12px; image-rendering:pixelated; cursor:crosshair; touch-action:none; width:640px; height:640px; box-shadow:0 10px 30px rgba(0,0,0,.45); position:relative; }
    #colorHistory{ display:flex; flex-wrap:wrap; gap:5px; margin-top:10px; max-width:320px; max-height:300px; overflow:auto; padding:8px; background:transparent; }
    #colorHistory::-webkit-scrollbar{ height:1000px; width:20px; }
    #colorHistory::-webkit-scrollbar-thumb{ background:var(--border); border-radius:4px; }
    #colorHistory::-webkit-scrollbar-track{ background:#020617; }
    #customColor{ width:90px; }
    .activeTool{ outline:30000px solid rgba(139,92,246,0.08); }
    
    /* TIMELINE STYLES */
    #timeline-container {
      margin-top: 20px;
      background: var(--panel);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
      border: 1px solid var(--border);
      width: 100%;
      max-width: 800px;
    }
    
    #timeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    #timeline-controls {
      display: flex;
      gap: 10px;
    }
    
    #frames-container {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding: 10px;
      background: var(--panel-2);
      border-radius: 8px;
      min-height: 150px;
    }
    
    .frame {
      position: relative;
      min-width: 120px;
      height: 120px;
      background: #0b1220;
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      flex-direction:column;
      align-items: center;
      justify-content: center;
    }
    
    .frame.active {
      border-color: var(--accent);
    }
    
    .frame canvas {
      width: 80px;
      height: 80px;
      image-rendering: pixelated;
      background: white;
    }
    
    .frame-number {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
    }
    
    .frame-duration {
      position: absolute;
      bottom: 5px;
      font-size: 11px;
      color: var(--muted);
    }
    
    .frame-actions {
      position: absolute;
      top: 5px;
      right: 5px;
      display: flex;
      gap: 3px;
    }
    
    .frame-btn {
      width: 20px;
      height: 20px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }
    
    #animation-preview {
      margin-top: 20px;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    #preview-canvas {
      background: white;
      border-radius: 8px;
      image-rendering: pixelated;
    }
    
    #preview-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    #playback-speed {
      width: 100px;
    }
    
    /* Frame duration controls */
    .frame-duration-controls {
      position: absolute;
      bottom: 5px;
      right: 5px;
      display: flex;
      gap: 2px;
    }
    
    .duration-btn {
      width: 18px;
      height: 18px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 2px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
    }
    
    .duration-btn:hover {
      background: var(--accent);
    }
    
    /* Custom speed input */
    #custom-speed-container {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-top: 10px;
    }
    
    #custom-speed-input {
      width: 80px;
      padding: 4px 8px;
    }
    
    #apply-custom-speed {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    /* Layout principal reorganizado */
    .main-content {
      display: flex;
      flex-direction:column;
      align-items: center;
      gap: 20px;
    }
    
    .canvas-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .canvas-with-tools {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    
    .tools-sidebar {
      display: flex;
      flex-direction: column;
      width: 200px;
    }

    /* Modal de importa√ß√£o */
    .import-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .import-modal-content {
      background: var(--panel);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid var(--border);
      width: 400px;
      max-width: 90%;
    }

    .import-options {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 15px;
    }

    .import-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--panel-2);
      border-radius: 8px;
      cursor: pointer;
      border: 1px solid var(--border);
    }

    .import-option:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .import-option input[type="radio"] {
      margin: 0;
    }

    .import-controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .import-control-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .import-control-row label {
      min-width: 150px;
      color: var(--muted);
    }

    .import-control-row input[type="number"] {
      width: 80px;
      padding: 6px 10px;
    }

    .import-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    /* Selection overlay */
    #selection-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
      border: 2px dashed var(--selection);
      background-color: rgba(59, 130, 246, 0.1);
      display: none;
    }

    /* Selection controls */
    .selection-controls {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      background: var(--panel);
      padding: 5px;
      border-radius: 6px;
      border: 1px solid var(--border);
      display: none;
      z-index: 20;
    }

    .selection-btn {
      width: 30px;
      height: 30px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .selection-btn:hover {
      background: var(--accent);
    }

    /* Tool cursors */
    .cursor-crosshair { cursor: crosshair; }
    .cursor-selection { cursor: move; }
    .cursor-bucket { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23000000" d="M19 10c0-1.1-.9-2-2-2h-2V7c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v1H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8zm-2 0h-2v1h2v-1zm-4 0h-2v1h2v-1zm-4 0H7v1h2v-1z"/></svg>') 0 24, auto; }
  </style>
</head>
<body>

<h1>Pixel Art Studio</h1>

<div class="main-content">
  <!-- TOOLBOX (ACIMA DO GRID) -->
  <div id="toolbar">

    <div class="toolbox-group">
      <h4>Arquivo</h4>
      <div class="toolbox-subrow">
        <div class="toolbox-row">
          <button id="newArt">Nova Arte</button>
          <button id="download">Baixar</button>
          <button id="downloadTransparent">PNG</button>
        </div>
        <div class="toolbox-row">
          <button id="importBtn">Importar</button>
        </div>
      </div>
    </div>

    <div class="toolbox-group">
      <h4>Editar</h4>
      <div class="toolbox-subrow">
        <div class="toolbox-row">
          <button id="undoBtn">Desfazer</button>
          <button id="redoBtn">Refazer</button>
          <button id="eraser">Borracha</button>
        </div>
        <div class="toolbox-row">
          <button id="bucketTool" class="activeTool">Balde</button>
          <button id="selectionTool">Sele√ß√£o</button>
        </div>
      </div>
    </div>

    <div class="toolbox-group">
      <h4>Grid</h4>
      <div class="toolbox-subrow">
        <div class="toolbox-row">
          <button id="toggleGrid" class="activeTool">Grid ON</button>
          <button id="toggleExportGrid" class="activeTool">Grid no Download</button>
        </div>
        <div class="toolbox-row">
          <label for="gridSize">Tamanho</label>
          <select id="gridSize">
            <option value="16" >16 x 16</option>
            <option value="32">32 x 32</option>
            <option value="64" selected>64 x 64</option>
            <option value="128">128 x 128</option>
            <option value="256">256 x 256</option>
          </select>
          <button id="createGrid">Criar Grid</button>
        </div>
      </div>
    </div>

    <div class="toolbox-group">
      <h4>Cores</h4>
      <div class="toolbox-subrow">
        <div class="toolbox-row">
          <input type="text" id="customColor" placeholder="#hex" />
          <button id="addColor">Criar Cor</button>
        </div>
        <div class="toolbox-row">
          <label style="font-size:12px;color:var(--muted)">Accent</label>
          <input type="color" id="accentPicker" value="#8b5cf6" />
        </div>
      </div>
    </div>

  </div>

  <!-- SE√á√ÉO DO CANVAS E FERRAMENTAS -->
  <div class="canvas-section">
    <div class="canvas-with-tools">
      <!-- CANVAS COM OVERLAY DE SELE√á√ÉO -->
      <div style="position:relative;">
        <canvas id="grid" width="640" height="640"></canvas>
        <div id="selection-overlay"></div>
        <div id="selection-controls" class="selection-controls">
          <button class="selection-btn" id="cutSelection" title="Recortar">‚úÇÔ∏è</button>
          <button class="selection-btn" id="copySelection" title="Copiar">üìã</button>
          <button class="selection-btn" id="pasteSelection" title="Colar">üìå</button>
          <button class="selection-btn" id="deleteSelection" title="Deletar">üóëÔ∏è</button>
          <button class="selection-btn" id="cancelSelection" title="Cancelar">‚úï</button>
        </div>
      </div>

      <!-- HIST√ìRICO DE CORES (LATERAL DO GRID) -->
      <div class="tools-sidebar">
        <h4 style="margin:0 0 10px 0; color:var(--muted)">Cores Recentes</h4>
        <div id="colorHistory"></div>
      </div>
    </div>
  </div>

  <!-- TIMELINE DE ANIMA√á√ÉO (ABAIXO DO GRID) -->
  <div id="timeline-container">
    <div id="timeline-header">
      <h3 style="margin:0;">Timeline de Anima√ß√£o</h3>
      <div id="timeline-controls">
        <button id="addFrame">+ Frame</button>
        <button id="duplicateFrame">Duplicar</button>
        <button id="deleteFrame">Remover</button>
        <button id="previewAnimation">Preview</button>
        <button id="exportGIF">Exportar GIF</button>
      </div>
    </div>
    
    <div id="frames-container">
      <!-- Frames ser√£o adicionados aqui dinamicamente -->
    </div>
    
    <!-- Controle de velocidade customizada -->
    <div id="custom-speed-container">
      <span style="font-size:12px; color:var(--muted)">Velocidade customizada (ms):</span>
      <input type="number" id="custom-speed-input" min="50" max="2000" step="50" value="250" />
      <button id="apply-custom-speed">Aplicar</button>
      <button id="apply-all-speed">Aplicar a todos</button>
    </div>
    
    <div id="animation-preview">
      <canvas id="preview-canvas" width="320" height="320"></canvas>
      <div id="preview-controls">
        <button id="playPause">‚ñ∂ Play</button>
        <button id="stopPreview">‚èπ Stop</button>
        <span>Velocidade:</span>
        <select id="playback-speed">
          <option value="1000">0.25x</option>
          <option value="500">0.5x</option>
          <option value="250" selected>1x</option>
          <option value="125">2x</option>
          <option value="62">4x</option>
          <option value="custom">Custom</option>
        </select>
        <span id="frame-counter">Frame: 1/1</span>
      </div>
    </div>
  </div>
</div>

<!-- Modal de importa√ß√£o -->
<div id="importModal" class="import-modal">
  <div class="import-modal-content">
    <h3 style="margin:0 0 15px 0;">Importar Imagem</h3>
    <div class="import-options">
      <label class="import-option">
        <input type="radio" name="importOption" value="fitToGrid" checked>
        <span>Ajustar ao grid atual</span>
      </label>
      <label class="import-option">
        <input type="radio" name="importOption" value="adaptGrid">
        <span>Adaptar grid √† imagem</span>
      </label>
    </div>
    
    <div class="import-controls" id="adaptiveControls" style="display:none;">
      <div class="import-control-row">
        <label>Colunas (largura):</label>
        <input type="number" id="importCols" min="8" max="512" value="64">
      </div>
      <div class="import-control-row">
        <label>Linhas (altura):</label>
        <input type="number" id="importRows" min="8" max="512" value="64">
      </div>
      <div style="font-size:12px; color:var(--muted); margin-top:10px;">
        Dica: Use valores altos para mais detalhes, valores baixos para pixel art mais estilizada.
      </div>
    </div>

    <div class="import-controls" id="fitControls">
      <div style="font-size:12px; color:var(--muted);">
        A imagem ser√° redimensionada para caber no grid atual de <span id="currentGridSize">64x64</span> pixels.
      </div>
    </div>

    <div class="import-buttons">
      <button id="cancelImport">Cancelar</button>
      <button id="confirmImport">Importar</button>
    </div>
  </div>
</div>

<script>
// accent color control
const accentPicker = document.getElementById('accentPicker');
accentPicker.addEventListener('input', (e)=>{
  const color = e.target.value;
  document.documentElement.style.setProperty('--accent', color);
  // darker hover automatically
  document.documentElement.style.setProperty('--accent-hover', color);
});

// --- setup ---
const artCanvas = document.getElementById('grid');
const ctx = artCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// offscreen buffer that stores pixel artwork (without grid)
const buffer = document.createElement('canvas');
const bctx = buffer.getContext('2d');
buffer.width = artCanvas.width;
buffer.height = artCanvas.height;

// state
let size = 64; // backward compatibility (square)
let gridCols = 64;
let gridRows = 64;
let cell = artCanvas.width / size;
let currentColor = '#000000';
let colorHistory = [];
let isDrawing = false;
let showGrid = true; // grid de visualiza√ß√£o
let includeGridOnExport = true; // grid no download

// undo/redo (store buffer dataURLs)
const undoStack = [];
const redoStack = [];

// TIMELINE STATE
let frames = [];
let currentFrameIndex = 0;
let isPlaying = false;
let playInterval = null;

// VARI√ÅVEIS PARA IMPORTAR
let importImageData = null;
let importImageWidth = 0;
let importImageHeight = 0;

// NOVAS VARI√ÅVEIS PARA FERRAMENTAS
let currentTool = 'pencil'; // 'pencil', 'eraser', 'bucket', 'selection'
let isSelecting = false;
let selectionStart = { x: 0, y: 0 };
let selectionEnd = { x: 0, y: 0 };
let selection = null; // { x, y, width, height, data }
let isMovingSelection = false;
let selectionOffset = { x: 0, y: 0 };
let clipboard = null; // Para copiar/colar

// Elementos da sele√ß√£o
const selectionOverlay = document.getElementById('selection-overlay');
const selectionControls = document.getElementById('selection-controls');

function pushUndo(){
  try{
    undoStack.push(buffer.toDataURL());
    if(undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
  }catch(e){console.warn('save failed',e);} 
}

function restoreBuffer(dataURL, callback){
  const img = new Image();
  img.onload = () => {
    bctx.clearRect(0,0,buffer.width,buffer.height);
    bctx.drawImage(img,0,0);
    renderAll();
    if(callback) callback();
  };
  img.src = dataURL;
}

function undo(){ if(undoStack.length===0) return; redoStack.push(buffer.toDataURL()); const last = undoStack.pop(); restoreBuffer(last); updateUndoRedoButtons(); }
function redo(){ if(redoStack.length===0) return; undoStack.push(buffer.toDataURL()); const next = redoStack.pop(); restoreBuffer(next); updateUndoRedoButtons(); }
function updateUndoRedoButtons(){ document.getElementById('undoBtn').disabled = undoStack.length===0; document.getElementById('redoBtn').disabled = redoStack.length===0; }

// draw grid path once per render to avoid double-stroke at intersections
function drawGridOnContext(targetCtx){
  const path = new Path2D();
  const cw = targetCtx === ctx ? artCanvas.width : buffer.width;
  const ch = targetCtx === ctx ? artCanvas.height : buffer.height;

  const stepX = cw / gridCols;
  const stepY = ch / gridRows;

  targetCtx.lineWidth = 0.7; // grid mais vis√≠vel
  targetCtx.strokeStyle = '#8a8a8a';

  // linhas verticais
  for(let i = 0; i <= gridCols; i++){
    const x = Math.round(i * stepX) + 0.5;
    path.moveTo(x, 0);
    path.lineTo(x, ch);
  }

  // linhas horizontais
  for(let j = 0; j <= gridRows; j++){
    const y = Math.round(j * stepY) + 0.5;
    path.moveTo(0, y);
    path.lineTo(cw, y);
  }

  targetCtx.stroke(path);

  // contorno final (direita e embaixo garantidos)
  targetCtx.strokeRect(0.5, 0.5, cw - 1, ch - 1);
}

// render: draw buffer (pixels) then grid on top
function renderAll(){
  ctx.clearRect(0,0,artCanvas.width,artCanvas.height);
  ctx.drawImage(buffer, 0, 0);
  if(showGrid){
    drawGridOnContext(ctx);
  }
  
  // Desenhar sele√ß√£o se existir
  if (selection) {
    drawSelection();
  }
}

function resizeBufferToCanvas(){ buffer.width = artCanvas.width; buffer.height = artCanvas.height; }

// ==============================================
// FERRAMENTA DE PINCEL/BORRACHA (modificada)
// ==============================================

function paintCellAt(xPixel, yPixel){
  if (currentTool === 'selection') return;
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;

  const x = Math.floor(xPixel / stepX);
  const y = Math.floor(yPixel / stepY);
  if(x < 0 || y < 0 || x >= gridCols || y >= gridRows) return;

  const px = Math.round(x * stepX);
  const py = Math.round(y * stepY);
  const w = Math.ceil(stepX);
  const h = Math.ceil(stepY);

  bctx.imageSmoothingEnabled = false;

  if(currentColor === 'eraser' || currentTool === 'eraser'){
    // apaga de verdade (transpar√™ncia real para PNG)
    bctx.clearRect(px, py, w, h);
  } else if (currentTool === 'pencil') {
    bctx.fillStyle = currentColor;
    bctx.fillRect(px, py, w, h);
  }
  
  // Limpar sele√ß√£o se estiver pintando
  if (selection && (currentTool === 'pencil' || currentTool === 'eraser')) {
    clearSelection();
  }

  renderAll();
}

// ==============================================
// FERRAMENTA DE BALDE (BUCKET FILL)
// ==============================================

function bucketFill(xPixel, yPixel){
  pushUndo();
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;

  const x = Math.floor(xPixel / stepX);
  const y = Math.floor(yPixel / stepY);
  
  if(x < 0 || y < 0 || x >= gridCols || y >= gridRows) return;
  
  // Obter a cor do pixel clicado
  const px = Math.round(x * stepX);
  const py = Math.round(y * stepY);
  const pixelData = bctx.getImageData(px, py, 1, 1).data;
  const targetColor = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3]/255})`;
  
  // Se a cor alvo for igual √† cor atual, n√£o fazer nada
  if (currentColor === 'eraser') {
    // Para preenchimento com "transpar√™ncia"
    floodFill(x, y, targetColor, 'transparent');
  } else {
    // Converter cor atual para rgba para compara√ß√£o
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.fillStyle = currentColor;
    tempCtx.fillRect(0, 0, 1, 1);
    const currentPixelData = tempCtx.getImageData(0, 0, 1, 1).data;
    const newColor = `rgba(${currentPixelData[0]}, ${currentPixelData[1]}, ${currentPixelData[2]}, ${currentPixelData[3]/255})`;
    
    if (targetColor !== newColor) {
      floodFill(x, y, targetColor, newColor);
    }
  }
  
  renderAll();
}

// Algoritmo de flood fill (preenchimento)
function floodFill(startX, startY, targetColor, newColor){
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  // Criar array de visitados
  const visited = new Array(gridCols * gridRows).fill(false);
  const stack = [{x: startX, y: startY}];
  
  while(stack.length > 0){
    const {x, y} = stack.pop();
    const index = y * gridCols + x;
    
    if(x < 0 || x >= gridCols || y < 0 || y >= gridRows) continue;
    if(visited[index]) continue;
    
    const px = Math.round(x * stepX);
    const py = Math.round(y * stepY);
    const pixelData = bctx.getImageData(px, py, 1, 1).data;
    const currentColor = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3]/255})`;
    
    // Comparar cores (com toler√¢ncia para alpha)
    if(currentColor === targetColor){
      visited[index] = true;
      
      // Pintar o pixel
      if(newColor === 'transparent'){
        bctx.clearRect(px, py, stepX, stepY);
      } else {
        bctx.fillStyle = newColor;
        bctx.fillRect(px, py, stepX, stepY);
      }
      
      // Adicionar vizinhos
      stack.push({x: x+1, y});
      stack.push({x: x-1, y});
      stack.push({x, y: y+1});
      stack.push({x, y: y-1});
    }
  }
}

// ==============================================
// FERRAMENTA DE SELE√á√ÉO
// ==============================================

function startSelection(xPixel, yPixel){
  isSelecting = true;
  selectionStart = { x: xPixel, y: yPixel };
  selectionEnd = { x: xPixel, y: yPixel };
  updateSelectionOverlay();
}

function updateSelection(xPixel, yPixel){
  if (!isSelecting) return;
  selectionEnd = { x: xPixel, y: yPixel };
  updateSelectionOverlay();
}

function endSelection(){
  if (!isSelecting) return;
  isSelecting = false;
  
  // Garantir que a sele√ß√£o tenha pelo menos 1 pixel
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const startCellX = Math.floor(selectionStart.x / stepX);
  const startCellY = Math.floor(selectionStart.y / stepY);
  const endCellX = Math.floor(selectionEnd.x / stepX);
  const endCellY = Math.floor(selectionEnd.y / stepY);
  
  const minX = Math.max(0, Math.min(startCellX, endCellX));
  const minY = Math.max(0, Math.min(startCellY, endCellY));
  const maxX = Math.min(gridCols-1, Math.max(startCellX, endCellX));
  const maxY = Math.min(gridRows-1, Math.max(startCellY, endCellY));
  
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  
  if (width > 0 && height > 0) {
    // Criar sele√ß√£o
    selection = {
      x: minX,
      y: minY,
      width: width,
      height: height,
      data: null
    };
    
    // Capturar dados da sele√ß√£o
    captureSelectionData();
    showSelectionControls();
  } else {
    clearSelection();
  }
}

function captureSelectionData(){
  if (!selection) return;
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(selection.x * stepX);
  const py = Math.round(selection.y * stepY);
  const pw = Math.round(selection.width * stepX);
  const ph = Math.round(selection.height * stepY);
  
  selection.data = bctx.getImageData(px, py, pw, ph);
}

function drawSelection(){
  if (!selection) return;
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(selection.x * stepX);
  const py = Math.round(selection.y * stepY);
  const pw = Math.round(selection.width * stepX);
  const ph = Math.round(selection.height * stepY);
  
  // Desenhar overlay da sele√ß√£o
  ctx.save();
  ctx.strokeStyle = 'var(--selection)';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.strokeRect(px + 0.5, py + 0.5, pw - 1, ph - 1);
  
  // Desenhar cantos
  ctx.setLineDash([]);
  ctx.fillStyle = 'var(--selection)';
  const cornerSize = 6;
  
  // Cantos
  ctx.fillRect(px - cornerSize/2, py - cornerSize/2, cornerSize, cornerSize);
  ctx.fillRect(px + pw - cornerSize/2, py - cornerSize/2, cornerSize, cornerSize);
  ctx.fillRect(px - cornerSize/2, py + ph - cornerSize/2, cornerSize, cornerSize);
  ctx.fillRect(px + pw - cornerSize/2, py + ph - cornerSize/2, cornerSize, cornerSize);
  
  ctx.restore();
}

function updateSelectionOverlay(){
  if (!isSelecting && !selection) {
    selectionOverlay.style.display = 'none';
    return;
  }
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  let px, py, pw, ph;
  
  if (isSelecting) {
    const startCellX = Math.floor(selectionStart.x / stepX);
    const startCellY = Math.floor(selectionStart.y / stepY);
    const endCellX = Math.floor(selectionEnd.x / stepX);
    const endCellY = Math.floor(selectionEnd.y / stepY);
    
    const minX = Math.max(0, Math.min(startCellX, endCellX));
    const minY = Math.max(0, Math.min(startCellY, endCellY));
    const maxX = Math.min(gridCols-1, Math.max(startCellX, endCellX));
    const maxY = Math.min(gridRows-1, Math.max(startCellY, endCellY));
    
    px = Math.round(minX * stepX);
    py = Math.round(minY * stepY);
    pw = Math.round((maxX - minX + 1) * stepX);
    ph = Math.round((maxY - minY + 1) * stepY);
  } else if (selection) {
    px = Math.round(selection.x * stepX);
    py = Math.round(selection.y * stepY);
    pw = Math.round(selection.width * stepX);
    ph = Math.round(selection.height * stepY);
  }
  
  if (pw > 0 && ph > 0) {
    selectionOverlay.style.left = px + 'px';
    selectionOverlay.style.top = py + 'px';
    selectionOverlay.style.width = pw + 'px';
    selectionOverlay.style.height = ph + 'px';
    selectionOverlay.style.display = 'block';
  }
}

function showSelectionControls(){
  if (!selection) return;
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(selection.x * stepX);
  const py = Math.round(selection.y * stepY);
  const ph = Math.round(selection.height * stepY);
  
  selectionControls.style.left = (px + (selection.width * stepX) / 2) + 'px';
  selectionControls.style.top = (py - 40) + 'px';
  selectionControls.style.display = 'flex';
}

function clearSelection(){
  selection = null;
  selectionOverlay.style.display = 'none';
  selectionControls.style.display = 'none';
  isMovingSelection = false;
  renderAll();
}

function cutSelection(){
  if (!selection) return;
  pushUndo();
  
  copySelection();
  
  // Apagar √°rea selecionada
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(selection.x * stepX);
  const py = Math.round(selection.y * stepY);
  const pw = Math.round(selection.width * stepX);
  const ph = Math.round(selection.height * stepY);
  
  bctx.clearRect(px, py, pw, ph);
  
  clearSelection();
  renderAll();
}

function copySelection(){
  if (!selection) return;
  clipboard = {
    data: selection.data,
    width: selection.width,
    height: selection.height
  };
}

function pasteSelection(){
  if (!clipboard) return;
  pushUndo();
  
  // Posicionar no centro do canvas
  const centerX = Math.floor(gridCols / 2 - clipboard.width / 2);
  const centerY = Math.floor(gridRows / 2 - clipboard.height / 2);
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(centerX * stepX);
  const py = Math.round(centerY * stepY);
  
  // Limpar sele√ß√£o anterior
  clearSelection();
  
  // Criar nova sele√ß√£o
  selection = {
    x: centerX,
    y: centerY,
    width: clipboard.width,
    height: clipboard.height,
    data: clipboard.data
  };
  
  // Colar dados
  bctx.putImageData(clipboard.data, px, py);
  
  showSelectionControls();
  renderAll();
}

function deleteSelection(){
  if (!selection) return;
  pushUndo();
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(selection.x * stepX);
  const py = Math.round(selection.y * stepY);
  const pw = Math.round(selection.width * stepX);
  const ph = Math.round(selection.height * stepY);
  
  bctx.clearRect(px, py, pw, ph);
  
  clearSelection();
  renderAll();
}

function startMovingSelection(xPixel, yPixel){
  if (!selection) return;
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const px = Math.round(selection.x * stepX);
  const py = Math.round(selection.y * stepY);
  const pw = Math.round(selection.width * stepX);
  const ph = Math.round(selection.height * stepY);
  
  // Verificar se o clique est√° dentro da sele√ß√£o
  if (xPixel >= px && xPixel <= px + pw && yPixel >= py && yPixel <= py + ph) {
    isMovingSelection = true;
    selectionOffset = {
      x: xPixel - px,
      y: yPixel - py
    };
  }
}

function moveSelection(xPixel, yPixel){
  if (!isMovingSelection || !selection) return;
  
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  // Calcular nova posi√ß√£o em c√©lulas
  const newX = Math.floor((xPixel - selectionOffset.x) / stepX);
  const newY = Math.floor((yPixel - selectionOffset.y) / stepY);
  
  // Limitar aos limites do canvas
  selection.x = Math.max(0, Math.min(newX, gridCols - selection.width));
  selection.y = Math.max(0, Math.min(newY, gridRows - selection.height));
  
  updateSelectionOverlay();
  showSelectionControls();
}

function endMovingSelection(){
  if (!isMovingSelection || !selection) return;
  
  isMovingSelection = false;
  pushUndo();
  
  // Recriar a imagem na nova posi√ß√£o
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;
  
  const oldPx = Math.round(selection.x * stepX);
  const oldPy = Math.round(selection.y * stepY);
  
  // Limpar √°rea original temporariamente
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = selection.data.width;
  tempCanvas.height = selection.data.height;
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.putImageData(selection.data, 0, 0);
  
  // Redesenhar a sele√ß√£o na nova posi√ß√£o
  bctx.drawImage(tempCanvas, oldPx, oldPy);
  
  renderAll();
}

function getPointerPos(evt){
  const rect = artCanvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const xCss = clientX - rect.left;
  const yCss = clientY - rect.top;
  const scaleX = artCanvas.width / rect.width;
  const scaleY = artCanvas.height / rect.height;
  return { x: xCss * scaleX, y: yCss * scaleY };
}

// ==============================================
// EVENT HANDLERS MODIFICADOS
// ==============================================

artCanvas.addEventListener('pointerdown', (e)=>{
  // left button only (button === 0)
  if(e.button !== undefined && e.button !== 0) return;
  
  const pos = getPointerPos(e);
  
  if (currentTool === 'selection') {
    if (selection && !isMovingSelection) {
      // Verificar se est√° clicando na sele√ß√£o para mov√™-la
      startMovingSelection(pos.x, pos.y);
    } else {
      // Come√ßar nova sele√ß√£o
      pushUndo(); // save state before edit
      startSelection(pos.x, pos.y);
    }
  } else if (currentTool === 'bucket') {
    pushUndo(); // save state before edit
    bucketFill(pos.x, pos.y);
  } else {
    pushUndo(); // save state before edit
    isDrawing = true;
    paintCellAt(pos.x, pos.y);
  }
  
  e.preventDefault();
});

window.addEventListener('pointerup', ()=>{
  if (isSelecting) {
    endSelection();
  }
  if (isMovingSelection) {
    endMovingSelection();
  }
  isDrawing = false;
});

artCanvas.addEventListener('pointermove', (e)=>{
  const pos = getPointerPos(e);
  
  if (isSelecting) {
    updateSelection(pos.x, pos.y);
  } else if (isMovingSelection) {
    moveSelection(pos.x, pos.y);
  } else if (isDrawing && (currentTool === 'pencil' || currentTool === 'eraser')) {
    paintCellAt(pos.x, pos.y);
  }
  
  e.preventDefault();
});

// Atualizar cursor baseado na ferramenta
function updateCursor(){
  switch(currentTool){
    case 'pencil':
    case 'eraser':
      artCanvas.className = 'cursor-crosshair';
      break;
    case 'selection':
      artCanvas.className = 'cursor-selection';
      break;
    case 'bucket':
      artCanvas.className = 'cursor-bucket';
      break;
  }
}

// ==============================================
// TOOL CONTROLS
// ==============================================

// Ferramenta Balde
const bucketToolBtn = document.getElementById('bucketTool');
bucketToolBtn.onclick = () => {
  currentTool = 'bucket';
  updateToolButtons();
  updateCursor();
  clearSelection();
};

// Ferramenta Sele√ß√£o
const selectionToolBtn = document.getElementById('selectionTool');
selectionToolBtn.onclick = () => {
  currentTool = 'selection';
  updateToolButtons();
  updateCursor();
};

// Ferramenta Borracha (j√° existente)
const eraserBtn = document.getElementById('eraser');
eraserBtn.onclick = () => {
  if (currentColor === 'eraser') {
    currentColor = '#000000';
    currentTool = 'pencil';
  } else {
    currentColor = 'eraser';
    currentTool = 'eraser';
  }
  updateToolButtons();
  updateCursor();
  clearSelection();
};

// Atualizar bot√µes de ferramentas
function updateToolButtons(){
  // Remover activeTool de todos os bot√µes de ferramenta
  document.querySelectorAll('#toolbar button').forEach(btn => {
    if (btn.id === 'bucketTool' || btn.id === 'selectionTool' || btn.id === 'eraser') {
      btn.classList.remove('activeTool');
    }
  });
  
  // Adicionar activeTool ao bot√£o correto
  if (currentTool === 'bucket') {
    bucketToolBtn.classList.add('activeTool');
  } else if (currentTool === 'selection') {
    selectionToolBtn.classList.add('activeTool');
  } else if (currentTool === 'eraser') {
    eraserBtn.classList.add('activeTool');
  } else if (currentTool === 'pencil') {
    // O pincel √© o padr√£o, nenhum bot√£o espec√≠fico
  }
}

// Controles da sele√ß√£o
document.getElementById('cutSelection').onclick = cutSelection;
document.getElementById('copySelection').onclick = copySelection;
document.getElementById('pasteSelection').onclick = pasteSelection;
document.getElementById('deleteSelection').onclick = deleteSelection;
document.getElementById('cancelSelection').onclick = clearSelection;

// ==============================================
// RESTANTE DO C√ìDIGO (mantido igual)
// ==============================================

// toolbar actions
document.getElementById('newArt').onclick = ()=>{ pushUndo(); bctx.clearRect(0,0,buffer.width,buffer.height); renderAll(); clearSelection(); };
document.getElementById('gridSize').onchange = (e)=>{
  const v = parseInt(e.target.value,10)||64;
  gridCols = v;
  gridRows = v;
  renderAll();
  clearSelection();
};

// Modal de importa√ß√£o
const importModal = document.getElementById('importModal');
const importOptionRadios = document.querySelectorAll('input[name="importOption"]');
const adaptiveControls = document.getElementById('adaptiveControls');
const fitControls = document.getElementById('fitControls');
const currentGridSizeSpan = document.getElementById('currentGridSize');
const importColsInput = document.getElementById('importCols');
const importRowsInput = document.getElementById('importRows');
const cancelImportBtn = document.getElementById('cancelImport');
const confirmImportBtn = document.getElementById('confirmImport');

// Atualizar tamanho do grid atual
function updateCurrentGridSize() {
  currentGridSizeSpan.textContent = `${gridCols}x${gridRows}`;
}

// Mostrar/ocultar controles baseado na op√ß√£o selecionada
importOptionRadios.forEach(radio => {
  radio.addEventListener('change', (e) => {
    if (e.target.value === 'adaptGrid') {
      adaptiveControls.style.display = 'block';
      fitControls.style.display = 'none';
      
      // Sugerir valores baseados na propor√ß√£o da imagem
      if (importImageWidth > 0 && importImageHeight > 0) {
        const aspectRatio = importImageWidth / importImageHeight;
        
        // Calcular valores sugeridos mantendo a propor√ß√£o
        let suggestedCols = 64;
        let suggestedRows = Math.round(suggestedCols / aspectRatio);
        
        // Garantir valores m√≠nimos
        if (suggestedRows < 8) {
          suggestedRows = 8;
          suggestedCols = Math.round(suggestedRows * aspectRatio);
        }
        
        // Limitar valores m√°ximos
        suggestedCols = Math.min(512, Math.max(8, suggestedCols));
        suggestedRows = Math.min(512, Math.max(8, suggestedRows));
        
        importColsInput.value = suggestedCols;
        importRowsInput.value = suggestedRows;
      }
    } else {
      adaptiveControls.style.display = 'none';
      fitControls.style.display = 'block';
    }
  });
});

cancelImportBtn.onclick = () => {
  importModal.style.display = 'none';
  importImageData = null;
};

// Importar imagem
document.getElementById('importBtn').onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        // Salvar dados da imagem para usar no modal
        importImageData = event.target.result;
        importImageWidth = img.width;
        importImageHeight = img.height;
        
        // Atualizar tamanho do grid atual no modal
        updateCurrentGridSize();
        
        // Mostrar modal de importa√ß√£o
        importModal.style.display = 'flex';
        
        // Resetar para op√ß√£o padr√£o
        document.querySelector('input[name="importOption"][value="fitToGrid"]').checked = true;
        adaptiveControls.style.display = 'none';
        fitControls.style.display = 'block';
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  };
  
  input.click();
};

// Confirmar importa√ß√£o
confirmImportBtn.onclick = () => {
  if (!importImageData) return;
  
  const importOption = document.querySelector('input[name="importOption"]:checked').value;
  
  const img = new Image();
  img.onload = () => {
    // Salvar estado atual no undo
    pushUndo();
    
    if (importOption === 'adaptGrid') {
      // ADAPTAR GRID √Ä IMAGEM
      const newCols = parseInt(importColsInput.value);
      const newRows = parseInt(importRowsInput.value);
      
      if (isNaN(newCols) || isNaN(newRows) || newCols < 8 || newCols > 512 || newRows < 8 || newRows > 512) {
        alert('Por favor, insira valores v√°lidos para colunas e linhas (8-512).');
        return;
      }
      
      // Atualizar tamanho do grid
      gridCols = newCols;
      gridRows = newRows;
      
      // Atualizar select do grid para refletir o novo tamanho
      document.getElementById('gridSize').value = newCols === newRows ? newCols.toString() : 'custom';
      
      // Calcular novo tamanho do canvas mantendo propor√ß√£o
      const canvasSize = 640;
      const aspectRatio = newCols / newRows;
      
      if (aspectRatio >= 1) {
        artCanvas.width = canvasSize;
        artCanvas.height = Math.round(canvasSize / aspectRatio);
      } else {
        artCanvas.height = canvasSize;
        artCanvas.width = Math.round(canvasSize * aspectRatio);
      }
      
      // Atualizar buffer
      buffer.width = artCanvas.width;
      buffer.height = artCanvas.height;
      
      // Limpar buffer
      bctx.clearRect(0, 0, buffer.width, buffer.height);
      
      // Calcular escala para preencher o canvas
      const scaleX = buffer.width / img.width;
      const scaleY = buffer.height / img.height;
      const scale = Math.max(scaleX, scaleY); // Preencher todo o canvas
      
      const newWidth = img.width * scale;
      const newHeight = img.height * scale;
      
      // Centralizar a imagem no canvas
      const offsetX = (buffer.width - newWidth) / 2;
      const offsetY = (buffer.height - newHeight) / 2;
      
      // Desenhar imagem redimensionada
      bctx.imageSmoothingEnabled = false;
      bctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
      
      // Aplicar pixeliza√ß√£o baseada no novo grid
      pixelateImageForGrid(newWidth, newHeight, offsetX, offsetY);
      
    } else {
      // AJUSTAR AO GRID ATUAL
      // Limpar buffer
      bctx.clearRect(0, 0, buffer.width, buffer.height);
      
      // Calcular propor√ß√µes para redimensionar imagem para o grid
      const scaleX = buffer.width / img.width;
      const scaleY = buffer.height / img.height;
      const scale = Math.min(scaleX, scaleY); // Manter propor√ß√£o
      
      const newWidth = img.width * scale;
      const newHeight = img.height * scale;
      
      // Centralizar a imagem no canvas
      const offsetX = (buffer.width - newWidth) / 2;
      const offsetY = (buffer.height - newHeight) / 2;
      
      // Desenhar imagem redimensionada
      bctx.imageSmoothingEnabled = false;
      bctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
      
      // Aplicar pixeliza√ß√£o para melhorar a visualiza√ß√£o pixel art
      pixelateImage(newWidth, newHeight, offsetX, offsetY);
    }
    
    // Atualizar display
    renderAll();
    
    // Se estiver na timeline, atualizar o frame atual
    if (frames.length > 0 && frames[currentFrameIndex]) {
      const frameCanvas = document.createElement('canvas');
      frameCanvas.width = buffer.width;
      frameCanvas.height = buffer.height;
      const frameCtx = frameCanvas.getContext('2d');
      frameCtx.drawImage(buffer, 0, 0);
      frames[currentFrameIndex].imageData = frameCanvas.toDataURL();
      renderFrames();
    }
    
    // Fechar modal
    importModal.style.display = 'none';
    importImageData = null;
    
    alert('Imagem importada com sucesso!');
  };
  img.src = importImageData;
};

// Fun√ß√£o para pixelar a imagem importada (para ajustar ao grid atual)
function pixelateImage(imgWidth, imgHeight, offsetX, offsetY) {
  // Obter dados da imagem original
  const imageData = bctx.getImageData(offsetX, offsetY, imgWidth, imgHeight);
  const data = imageData.data;
  
  // Tamanho do "pixel" baseado no grid
  const pixelSize = Math.max(1, Math.floor(imgWidth / gridCols));
  
  // Aplicar efeito de pixeliza√ß√£o
  for (let y = 0; y < imgHeight; y += pixelSize) {
    for (let x = 0; x < imgWidth; x += pixelSize) {
      // Pegar a cor do pixel central do bloco
      const centerX = Math.min(x + Math.floor(pixelSize / 2), imgWidth - 1);
      const centerY = Math.min(y + Math.floor(pixelSize / 2), imgHeight - 1);
      const index = (centerY * imgWidth + centerX) * 4;
      
      const r = data[index];
      const g = data[index + 1];
      const b = data[index + 2];
      const a = data[index + 3];
      
      // Preencher o bloco inteiro com essa cor
      for (let py = 0; py < pixelSize; py++) {
        for (let px = 0; px < pixelSize; px++) {
          const currentX = x + px;
          const currentY = y + py;
          
          if (currentX < imgWidth && currentY < imgHeight) {
            const currentIndex = (currentY * imgWidth + currentX) * 4;
            data[currentIndex] = r;
            data[currentIndex + 1] = g;
            data[currentIndex + 2] = b;
            data[currentIndex + 3] = a;
          }
        }
      }
    }
  }
  
  // Colocar os dados pixelados de volta no buffer
  bctx.putImageData(imageData, offsetX, offsetY);
}

// Fun√ß√£o para pixelar imagem quando o grid √© adaptado
function pixelateImageForGrid(imgWidth, imgHeight, offsetX, offsetY) {
  // Obter dados da imagem original
  const imageData = bctx.getImageData(offsetX, offsetY, imgWidth, imgHeight);
  const data = imageData.data;
  
  // Tamanho do pixel baseado no novo grid
  const pixelWidth = imgWidth / gridCols;
  const pixelHeight = imgHeight / gridRows;
  
  // Aplicar efeito de pixeliza√ß√£o para o novo grid
  for (let row = 0; row < gridRows; row++) {
    for (let col = 0; col < gridCols; col++) {
      // Calcular posi√ß√£o do pixel no grid
      const xStart = Math.floor(col * pixelWidth);
      const yStart = Math.floor(row * pixelHeight);
      const xEnd = Math.floor((col + 1) * pixelWidth);
      const yEnd = Math.floor((row + 1) * pixelHeight);
      
      // Calcular cor m√©dia da √°rea
      let r = 0, g = 0, b = 0, a = 0;
      let count = 0;
      
      for (let y = yStart; y < yEnd && y < imgHeight; y++) {
        for (let x = xStart; x < xEnd && x < imgWidth; x++) {
          const index = (y * imgWidth + x) * 4;
          r += data[index];
          g += data[index + 1];
          b += data[index + 2];
          a += data[index + 3];
          count++;
        }
      }
      
      if (count > 0) {
        r = Math.round(r / count);
        g = Math.round(g / count);
        b = Math.round(b / count);
        a = Math.round(a / count);
        
        // Preencher toda a √°rea com a cor m√©dia
        for (let y = yStart; y < yEnd && y < imgHeight; y++) {
          for (let x = xStart; x < xEnd && x < imgWidth; x++) {
            const index = (y * imgWidth + x) * 4;
            data[index] = r;
            data[index + 1] = g;
            data[index + 2] = b;
            data[index + 3] = a;
          }
        }
      }
    }
  }
  
  // Colocar os dados pixelados de volta no buffer
  bctx.putImageData(imageData, offsetX, offsetY);
}

// download PNG com fundo (respeita op√ß√£o de grid no download)
document.getElementById('download').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // fundo branco
  tctx.fillStyle = "white";
  tctx.fillRect(0, 0, tmp.width, tmp.height);

  // arte
  tctx.drawImage(buffer,0,0);

  // grid opcional no export
  if(includeGridOnExport){
    drawGridOnContext(tctx);
  }

  const link = document.createElement('a');
  link.download = 'pixel_art.png';
  link.href = tmp.toDataURL('image/png');
  link.click();
};

// download PNG transparente
document.getElementById('downloadTransparent').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // transparente por padr√£o
  tctx.clearRect(0, 0, tmp.width, tmp.height);

  // arte
  tctx.drawImage(buffer,0,0);

  // grid opcional no export
  if(includeGridOnExport){
    drawGridOnContext(tctx);
  }

  const link = document.createElement('a');
  link.download = 'pixel_art_transparente.png';
  link.href = tmp.toDataURL('image/png');
  link.click();
};

// grid toggle (visualiza√ß√£o)
const toggleGridBtn = document.getElementById('toggleGrid');
toggleGridBtn.onclick = ()=>{
  showGrid = !showGrid;
  toggleGridBtn.textContent = showGrid ? 'Grid ON' : 'Grid OFF';
  toggleGridBtn.classList.toggle('activeTool', showGrid);
  renderAll();
};

// grid no download toggle
const toggleExportGridBtn = document.getElementById('toggleExportGrid');
toggleExportGridBtn.onclick = ()=>{
  includeGridOnExport = !includeGridOnExport;
  toggleExportGridBtn.textContent = includeGridOnExport ? 'Grid no Download' : 'Sem Grid no Download';
  toggleExportGridBtn.classList.toggle('activeTool', includeGridOnExport);
};

// undo/redo buttons
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// color history
function addColorToHistory(hex){ if(!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)) return; if(!colorHistory.includes(hex)){ colorHistory.push(hex); const div = document.getElementById('colorHistory'); const btn = document.createElement('div'); btn.className='color-btn'; btn.style.background=hex; btn.title=hex; btn.onclick = ()=>{
        currentColor = hex;
        currentTool = 'pencil';
        updateToolButtons();
        updateCursor();
        document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected'));
        btn.classList.add('selected');
      }; div.appendChild(btn); } }

document.getElementById('addColor').onclick = ()=>{ const hex = document.getElementById('customColor').value.trim(); if(/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)){ addColorToHistory(hex); currentColor = hex; currentTool = 'pencil'; updateToolButtons(); updateCursor(); eraserBtn.classList.remove('activeTool'); document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected')); const last = document.querySelector('#colorHistory .color-btn:last-child'); if(last) last.classList.add('selected'); } else alert('HEX inv√°lido. Use #fff ou #1a2b3c'); };

// create custom grid
document.getElementById('createGrid').onclick = ()=>{
  const w = parseInt(prompt('Largura do grid (colunas):'),10);
  const h = parseInt(prompt('Altura do grid (linhas):'),10);
  if(!w || !h || w<=0 || h<=0) return alert('Valores inv√°lidos');

  gridCols = w;
  gridRows = h;

  artCanvas.width = 640;
  artCanvas.height = Math.round(640 * (h / w));
  buffer.width = artCanvas.width;
  buffer.height = artCanvas.height;

  renderAll();
  clearSelection();
};

// seed colors
const seeds = ['#000000', '#141414', '#242424', '#333333','#424242', '#5c5c5c','#737373', '#8c8c8c', '#a3a3a3', '#bdbdbd', '#e0e0e0', '#2b3733',
               '#4a5451', '#6b7471','#8e9592', '#b2b7b5', 
               '#140700', '#1e1106', '#311b0c','#462510', '5c3011', '#733a13', '#8b4513','#a26238', '#b8805d','#cc9e83', '#e4a991',
               '#debeab', '#f1cbbc', '#b57d66','#8e6352', '#694a3e','#46322b', '#261d19', '#432422', '#592d2c', '#703735',
              '#6b2700', '#a33c00','#e05200', '#ff7221','#ff8742', '#241400','#573000', '#8f4f01','#d17b11', '#ff8c00','#ffa230', '#ffb357', ,'#ffc37a', '#ffd5a1', 
               '#1c1700', '#453a06','#705e00', '#9e8715', '#bf9f00', '#e3c21b','#ffd500', '#ffe042','#232400', '#5a5c00','#8a8c00', '#bcbf00','#9d9e42', '#bebf6f', 
              '#121a00','#2f3d0a', '#475919','#5c702a', '#90ab4d','#658c00', '#8bbf08','#60a302', '#315400','#102900', '#286300','#42a600', '#051c00','#105700', '#1c9600','#28db00', '#009405', 
              , '#0c4228','#0c6e3e', '#0eab5f','#10e880', '#3af098','#6af7b3', '#001c13', '#014d35', '#11664b', '#2c9473','#00ad76','#508f7b', '#82b8a7', '#024039', '#0f665c','#009c89', '#00c9b2','#00ffe1', '#75d1c6','#a8ede5', 
               '#00757d','#00a7b3', '#2ebfc9','#69cfd6', '#005273','#0082b5', '#1990bf','#00a6e8', '#35bdf2', '#000914', '#001938','#0a284d', '#00316e','#004dab', '#1a68c7','#4480c9', '#000926','#001454', '#152559','#000057', 
               '#000096','#0a0ad1', '#1a009e', '#1d144a','#362b70', '#574999','#897ec2', '#110033','#29007a', '#4000bf','#120021', '#300059','#53009c', '#7208cf','#2e0040', '#5f0085','#8415b0', '#b631eb','#ca57f7', '#d47cf7',
               '#de9ef7', '#e5b7f7','#e5b7f7', '#1c001b','#52004f', '#960091', '#cc02c5','#690050', '#b5008b','#1f0011', '#4d002b','#610d3c', '#8a014f','#ba026a', '#ff0090','#57001e', '#a10e42','#de0d56', 
              '#240000','#570000', '#800000','#ab0000', '#f20202','#521414', '#8f2222', '#d13232','#632d2d', '#964545','#c25555', '#ff7070','#db7d7d', '#ffa8a8','#a17777', '#f0bbbb', 
  '#1a0500', '#1a0900','#1a0e00', '#1a1200','#1a1700', '#161a00','#101a00', '#0a1a00','#001a01', '#001a08', '#001a0f', '#001a15','#00171a', '#00101a','#00081a', '#00011a','#06001a', '#0d001a','#14001a', '#1a0017', '#1a0011', '#1a000a','#1a0003'];
seeds.forEach(addColorToHistory);

// initial
renderAll(); undoStack.push(buffer.toDataURL()); updateUndoRedoButtons();
updateCurrentGridSize(); // Atualizar tamanho do grid no modal
updateCursor(); // Atualizar cursor inicial

// ==============================================
// CORRE√á√ÉO DOS ATALHOS DE TECLADO
// ==============================================

// keyboard shortcuts: Z undo, X redo, E toggle eraser, B bucket, S selection
window.addEventListener('keydown', (e)=>{
  // Verificar se n√£o est√° em um campo de entrada
  const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT';
  if (isInput) return;
  
  // Prevenir comportamento padr√£o para atalhos que usamos
  if (e.key === 'z' || e.key === 'Z' || e.key === 'x' || e.key === 'X' || 
      e.key === 'e' || e.key === 'E' || e.key === 'b' || e.key === 'B' || 
      e.key === 's' || e.key === 'S' || e.key === 'p' || e.key === 'P' ||
      e.key === 'Delete' || e.key === 'Backspace' || e.key === 'Escape') {
    e.preventDefault();
  }
  
  // Atalhos com Ctrl (ou Cmd no Mac)
  if(e.ctrlKey || e.metaKey) {
    if(e.key === 'z' || e.key === 'Z') {
      undo();
    }
    if(e.key === 'x' || e.key === 'X') {
      redo();
    }
    if(e.key === 'c' || e.key === 'C') {
      copySelection();
    }
    if(e.key === 'v' || e.key === 'V') {
      pasteSelection();
    }
  } else {
    // Atalhos sem Ctrl
    if(e.key === 'z' || e.key === 'Z'){ 
      undo();
    }
    if(e.key === 'x' || e.key === 'X'){ 
      redo();
    }
    if(e.key === 'e' || e.key === 'E'){ 
      currentColor = 'eraser'; 
      currentTool = 'eraser';
      updateToolButtons();
      updateCursor();
      clearSelection();
    }
    if(e.key === 'b' || e.key === 'B'){ 
      currentTool = 'bucket';
      updateToolButtons();
      updateCursor();
      clearSelection();
    }
    if(e.key === 's' || e.key === 'S'){ 
      currentTool = 'selection';
      updateToolButtons();
      updateCursor();
    }
    if(e.key === 'p' || e.key === 'P'){ 
      currentTool = 'pencil';
      updateToolButtons();
      updateCursor();
      clearSelection();
    }
    if(e.key === 'Delete' || e.key === 'Backspace') {
      deleteSelection();
    }
    if(e.key === 'Escape') {
      clearSelection();
    }
  }
});

// right-click paints with eraser (single cell)
artCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const pos = getPointerPos(e);
  pushUndo();
  const old = currentColor;
  const oldTool = currentTool;
  currentColor = 'eraser';
  currentTool = 'eraser';
  paintCellAt(pos.x, pos.y);
  currentColor = old;
  currentTool = oldTool;
  updateToolButtons();
  updateCursor();
});

// zoom: dblclick (PC) and double-tap (mobile) ‚Äî mobile requires taps near same spot
let zoomed = false;
function toggleZoom(){ zoomed = !zoomed; if(zoomed){ artCanvas.style.transform = 'scale(2)'; artCanvas.style.transformOrigin = 'center center'; } else { artCanvas.style.transform = 'scale(1)'; } }
artCanvas.addEventListener('dblclick', ()=>{ toggleZoom(); });

let lastTapTime = 0; let lastTapX = 0; let lastTapY = 0;
artCanvas.addEventListener('touchend', (e)=>{
  const now = Date.now();
  const touch = e.changedTouches[0];
  const x = touch.clientX; const y = touch.clientY;
  const dt = now - lastTapTime; const dist = Math.hypot(x - lastTapX, y - lastTapY);
  if(dt < 300 && dist < 25) toggleZoom();
  lastTapTime = now; lastTapX = x; lastTapY = y;
});

// ==============================================
// TIMELINE FUNCTIONS - CORRIGIDAS
// ==============================================

function saveCurrentFrame() {
  if (frames[currentFrameIndex]) {
    const frameCanvas = document.createElement('canvas');
    frameCanvas.width = buffer.width;
    frameCanvas.height = buffer.height;
    const frameCtx = frameCanvas.getContext('2d');
    frameCtx.drawImage(buffer, 0, 0);
    frames[currentFrameIndex].imageData = frameCanvas.toDataURL();
  }
}

function loadFrame(index) {
  if (frames[index]) {
    const img = new Image();
    img.onload = () => {
      bctx.clearRect(0, 0, buffer.width, buffer.height);
      bctx.drawImage(img, 0, 0);
      renderAll();
      clearSelection();
    };
    img.src = frames[index].imageData;
    currentFrameIndex = index;
    updateFrameDisplay();
  }
}

function addFrame() {
  saveCurrentFrame();
  
  // CRIAR FRAME EM BRANCO (n√£o copia o conte√∫do atual)
  const frameCanvas = document.createElement('canvas');
  frameCanvas.width = buffer.width;
  frameCanvas.height = buffer.height;
  const frameCtx = frameCanvas.getContext('2d');
  
  // Limpar o canvas do novo frame (frame em branco)
  frameCtx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
  
  // Adicionar o frame em branco
  frames.push({
    imageData: frameCanvas.toDataURL(),
    duration: 250 // ms
  });
  
  currentFrameIndex = frames.length - 1;
  
  // Carregar o novo frame em branco
  loadFrame(currentFrameIndex);
  renderFrames();
  updateFrameDisplay();
}

function duplicateFrame() {
  if (frames.length === 0) return;
  
  saveCurrentFrame();
  
  // DUPLICAR realmente copia o frame atual
  const frameCanvas = document.createElement('canvas');
  frameCanvas.width = buffer.width;
  frameCanvas.height = buffer.height;
  const frameCtx = frameCanvas.getContext('2d');
  frameCtx.drawImage(buffer, 0, 0);
  
  frames.splice(currentFrameIndex + 1, 0, {
    imageData: frameCanvas.toDataURL(),
    duration: frames[currentFrameIndex].duration
  });
  
  currentFrameIndex++;
  loadFrame(currentFrameIndex);
  renderFrames();
  updateFrameDisplay();
}

function deleteFrame() {
  if (frames.length <= 1) return;
  
  frames.splice(currentFrameIndex, 1);
  
  if (currentFrameIndex >= frames.length) {
    currentFrameIndex = frames.length - 1;
  }
  
  loadFrame(currentFrameIndex);
  renderFrames();
  updateFrameDisplay();
}

function updateFrameDuration(index, change) {
  if (frames[index]) {
    let newDuration = frames[index].duration + change;
    // Limitar entre 50ms e 2000ms
    newDuration = Math.max(50, Math.min(2000, newDuration));
    frames[index].duration = newDuration;
    renderFrames();
  }
}

function renderFrames() {
  const container = document.getElementById('frames-container');
  container.innerHTML = '';
  
  frames.forEach((frame, index) => {
    const frameDiv = document.createElement('div');
    frameDiv.className = `frame ${index === currentFrameIndex ? 'active' : ''}`;
    frameDiv.onclick = () => {
      saveCurrentFrame();
      loadFrame(index);
    };
    
    const frameNumber = document.createElement('div');
    frameNumber.className = 'frame-number';
    frameNumber.textContent = index + 1;
    
    const frameCanvas = document.createElement('canvas');
    frameCanvas.width = 80;
    frameCanvas.height = 80;
    const frameCtx = frameCanvas.getContext('2d');
    
    const img = new Image();
    img.onload = () => {
      frameCtx.drawImage(img, 0, 0, 80, 80);
    };
    img.src = frame.imageData;
    
    const frameDuration = document.createElement('div');
    frameDuration.className = 'frame-duration';
    frameDuration.textContent = `${frame.duration}ms`;
    
    // Controles de dura√ß√£o
    const durationControls = document.createElement('div');
    durationControls.className = 'frame-duration-controls';
    
    const minusBtn = document.createElement('button');
    minusBtn.className = 'duration-btn';
    minusBtn.innerHTML = '-';
    minusBtn.onclick = (e) => {
      e.stopPropagation();
      updateFrameDuration(index, -50);
    };
    
    const plusBtn = document.createElement('button');
    plusBtn.className = 'duration-btn';
    plusBtn.innerHTML = '+';
    plusBtn.onclick = (e) => {
      e.stopPropagation();
      updateFrameDuration(index, 50);
    };
    
    durationControls.appendChild(minusBtn);
    durationControls.appendChild(plusBtn);
    
    const frameActions = document.createElement('div');
    frameActions.className = 'frame-actions';
    
    const upBtn = document.createElement('button');
    upBtn.className = 'frame-btn';
    upBtn.innerHTML = '‚Üë';
    upBtn.onclick = (e) => {
      e.stopPropagation();
      if (index > 0) {
        [frames[index], frames[index - 1]] = [frames[index - 1], frames[index]];
        currentFrameIndex = index - 1;
        renderFrames();
        updateFrameDisplay();
      }
    };
    
    const downBtn = document.createElement('button');
    downBtn.className = 'frame-btn';
    downBtn.innerHTML = '‚Üì';
    downBtn.onclick = (e) => {
      e.stopPropagation();
      if (index < frames.length - 1) {
        [frames[index], frames[index + 1]] = [frames[index + 1], frames[index]];
        currentFrameIndex = index + 1;
        renderFrames();
        updateFrameDisplay();
      }
    };
    
    frameActions.appendChild(upBtn);
    frameActions.appendChild(downBtn);
    
    frameDiv.appendChild(frameNumber);
    frameDiv.appendChild(frameCanvas);
    frameDiv.appendChild(frameDuration);
    frameDiv.appendChild(durationControls);
    frameDiv.appendChild(frameActions);
    container.appendChild(frameDiv);
  });
}

function updateFrameDisplay() {
  document.querySelectorAll('.frame').forEach((frame, index) => {
    frame.classList.toggle('active', index === currentFrameIndex);
  });
  document.getElementById('frame-counter').textContent = `Frame: ${currentFrameIndex + 1}/${frames.length}`;
}

function previewAnimation() {
  const previewContainer = document.getElementById('animation-preview');
  const previewCanvas = document.getElementById('preview-canvas');
  const previewCtx = previewCanvas.getContext('2d');
  const frameCounter = document.getElementById('frame-counter');
  const playPauseBtn = document.getElementById('playPause');
  const playbackSpeed = document.getElementById('playback-speed');
  
  previewContainer.style.display = 'flex';
  
  if (frames.length === 0) {
    alert('Adicione pelo menos um frame para visualizar a anima√ß√£o!');
    return;
  }
  
  let previewFrameIndex = 0;
  
  function drawPreviewFrame() {
    if (frames[previewFrameIndex]) {
      const img = new Image();
      img.onload = () => {
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
        frameCounter.textContent = `Frame: ${previewFrameIndex + 1}/${frames.length}`;
      };
      img.src = frames[previewFrameIndex].imageData;
    }
  }
  
  function playAnimation() {
    if (isPlaying) return;
    
    isPlaying = true;
    playPauseBtn.textContent = '‚è∏ Pause';
    
    let speed;
    if (playbackSpeed.value === 'custom') {
      speed = parseInt(document.getElementById('custom-speed-input').value);
    } else {
      speed = parseInt(playbackSpeed.value);
    }
    
    playInterval = setInterval(() => {
      previewFrameIndex = (previewFrameIndex + 1) % frames.length;
      drawPreviewFrame();
    }, speed);
  }
  
  function pauseAnimation() {
    if (!isPlaying) return;
    
    isPlaying = false;
    playPauseBtn.textContent = '‚ñ∂ Play';
    clearInterval(playInterval);
  }
  
  function stopAnimation() {
    isPlaying = false;
    playPauseBtn.textContent = '‚ñ∂ Play';
    clearInterval(playInterval);
    previewFrameIndex = 0;
    drawPreviewFrame();
  }
  
  playPauseBtn.onclick = () => {
    if (isPlaying) {
      pauseAnimation();
    } else {
      playAnimation();
    }
  };
  
  document.getElementById('stopPreview').onclick = stopAnimation;
  
  playbackSpeed.onchange = () => {
    if (isPlaying) {
      pauseAnimation();
      playAnimation();
    }
  };
  
  drawPreviewFrame();
}

function exportGIF() {
  if (frames.length === 0) {
    alert('Adicione pelo menos um frame para exportar como GIF!');
    return;
  }
  
  alert('Exportar GIF - Esta funcionalidade requer uma biblioteca externa como gif.js. Para implementa√ß√£o completa, adicione a biblioteca gif.js ao projeto.');
}

// Aplicar velocidade customizada ao frame atual
document.getElementById('apply-custom-speed').onclick = () => {
  const customSpeed = parseInt(document.getElementById('custom-speed-input').value);
  if (isNaN(customSpeed) || customSpeed < 50 || customSpeed > 2000) {
    alert('Por favor, insira um valor entre 50 e 2000 ms');
    return;
  }
  
  if (frames[currentFrameIndex]) {
    frames[currentFrameIndex].duration = customSpeed;
    renderFrames();
    alert(`Velocidade do frame ${currentFrameIndex + 1} atualizada para ${customSpeed}ms`);
  }
};

// Aplicar velocidade customizada a todos os frames
document.getElementById('apply-all-speed').onclick = () => {
  const customSpeed = parseInt(document.getElementById('custom-speed-input').value);
  if (isNaN(customSpeed) || customSpeed < 50 || customSpeed > 2000) {
    alert('Por favor, insira um valor entre 50 e 2000 ms');
    return;
  }
  
  frames.forEach(frame => {
    frame.duration = customSpeed;
  });
  
  renderFrames();
  alert(`Velocidade de todos os frames atualizada para ${customSpeed}ms`);
};

// Event listeners for timeline controls
document.getElementById('addFrame').onclick = addFrame;
document.getElementById('duplicateFrame').onclick = duplicateFrame;
document.getElementById('deleteFrame').onclick = deleteFrame;
document.getElementById('previewAnimation').onclick = previewAnimation;
document.getElementById('exportGIF').onclick = exportGIF;

// Add initial frame (frame em branco)
addFrame();
  
  

</script>
</body>
</html>
