<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Art Studio</title>
  <style>
    body{ margin:0; background:#f5f5f5; font-family:Arial, Helvetica, sans-serif; display:flex; flex-direction:column; align-items:center; padding:20px; }
    #toolbar{ display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; align-items:center; }
    button, select, input{ padding:6px 8px; font-size:14px; }
    .color-btn{ width:28px; height:28px; border:1px solid #000; cursor:pointer; box-sizing:border-box; display:inline-block; }
    .color-btn.selected{ outline:3px solid #333; }
    #grid{ background:white; border:none; image-rendering:pixelated; cursor:crosshair; touch-action:none; width:640px; height:640px; }
    #colorHistory{ display:flex; flex-wrap:wrap; gap:5px; margin-top:10px; max-width:640px; max-height:160px; overflow:auto; padding:5px; background:transparent; }
    #colorHistory .color-btn{ flex:0 0 calc((640px - 19*5px) / 20); }
    #colorHistory::-webkit-scrollbar{ height:10px; width:10px; }
    #colorHistory::-webkit-scrollbar-thumb{ background:#888; border-radius:4px; }
    #colorHistory::-webkit-scrollbar-track{ background:#e0e0e0; }
    #customColor{ width:90px; }
    .activeTool{ outline:3px solid rgba(0,0,0,0.08); }
  </style>
</head>
<body>

<h1>Pixel Art Studio</h1>

<div id="toolbar">
  <button id="createGrid">Criar Grid</button>
  <button id="newArt">Nova Arte</button>
  <button id="undoBtn">Desfazer</button>
  <button id="redoBtn">Refazer</button>
  <button id="download">Download</button>
  <button id="eraser">Borracha</button>

  <label for="gridSize">Grid:</label>
  <select id="gridSize">
    <option value="16">16 x 16</option>
    <option value="32">32 x 32</option>
    <option value="64" selected>64 x 64</option>
    <option value="128">128 x 128</option>
    <option value="256">256 x 256</option>
  </select>

  <input type="text" id="customColor" placeholder="#hex" />
  <button id="addColor">Criar Cor</button>
</div>

<canvas id="grid" width="640" height="640"></canvas>

<h3>Histórico de Cores</h3>
<div id="colorHistory"></div>

<script>
// --- setup ---
const artCanvas = document.getElementById('grid');
const ctx = artCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// offscreen buffer that stores pixel artwork (without grid)
const buffer = document.createElement('canvas');
const bctx = buffer.getContext('2d');
buffer.width = artCanvas.width;
buffer.height = artCanvas.height;

// state
let size = 64; // backward compatibility (square)
let gridCols = 64;
let gridRows = 64;
let cell = artCanvas.width / size;
let currentColor = '#000000';
let colorHistory = [];
let isDrawing = false;

// undo/redo (store buffer dataURLs)
const undoStack = [];
const redoStack = [];

function pushUndo(){
  try{
    undoStack.push(buffer.toDataURL());
    if(undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
    updateUndoRedoButtons();
  }catch(e){console.warn('save failed',e);} 
}

function restoreBuffer(dataURL, callback){
  const img = new Image();
  img.onload = () => {
    bctx.clearRect(0,0,buffer.width,buffer.height);
    bctx.drawImage(img,0,0);
    renderAll();
    if(callback) callback();
  };
  img.src = dataURL;
}

function undo(){ if(undoStack.length===0) return; redoStack.push(buffer.toDataURL()); const last = undoStack.pop(); restoreBuffer(last); updateUndoRedoButtons(); }
function redo(){ if(redoStack.length===0) return; undoStack.push(buffer.toDataURL()); const next = redoStack.pop(); restoreBuffer(next); updateUndoRedoButtons(); }
function updateUndoRedoButtons(){ document.getElementById('undoBtn').disabled = undoStack.length===0; document.getElementById('redoBtn').disabled = redoStack.length===0; }

// draw grid path once per render to avoid double-stroke at intersections
function drawGridOnContext(targetCtx){
  const path = new Path2D();
  const cw = targetCtx === ctx ? artCanvas.width : buffer.width;
  const ch = targetCtx === ctx ? artCanvas.height : buffer.height;

  const stepX = cw / gridCols;
  const stepY = ch / gridRows;

  targetCtx.lineWidth = 0.7; // grid mais visível
  targetCtx.strokeStyle = '#8a8a8a';

  for(let i=0;i<=gridCols;i++){
    const x = Math.round(i * stepX) + 0.5;
    path.moveTo(x, 0);
    path.lineTo(x, ch);
  }

  for(let j=0;j<=gridRows;j++){
    const y = Math.round(j * stepY) + 0.5;
    path.moveTo(0, y);
    path.lineTo(cw, y);
  }

  targetCtx.stroke(path);
}

// render: draw buffer (pixels) then grid on top
function renderAll(){
  // clear main ctx
  ctx.clearRect(0,0,artCanvas.width,artCanvas.height);
  // draw buffer (scaled 1:1)
  ctx.drawImage(buffer, 0, 0);
  // draw grid lines on top (single path)
  drawGridOnContext(ctx);
}

function resizeBufferToCanvas(){ buffer.width = artCanvas.width; buffer.height = artCanvas.height; }

function paintCellAt(xPixel, yPixel){
  const stepX = artCanvas.width / gridCols;
  const stepY = artCanvas.height / gridRows;

  const x = Math.floor(xPixel / stepX);
  const y = Math.floor(yPixel / stepY);
  if(x < 0 || y < 0 || x >= gridCols || y >= gridRows) return;

  const px = Math.round(x * stepX);
  const py = Math.round(y * stepY);
  const w = Math.ceil(stepX);
  const h = Math.ceil(stepY);

  bctx.imageSmoothingEnabled = false;
  bctx.fillStyle = (currentColor === 'eraser') ? 'white' : currentColor;
  bctx.fillRect(px, py, w, h);

  renderAll();
}

function getPointerPos(evt){
  const rect = artCanvas.getBoundingClientRect();
  const clientX = (evt.touches && evt.touches[0]) ? evt.touches[0].clientX : evt.clientX;
  const clientY = (evt.touches && evt.touches[0]) ? evt.touches[0].clientY : evt.clientY;
  const xCss = clientX - rect.left;
  const yCss = clientY - rect.top;
  const scaleX = artCanvas.width / rect.width;
  const scaleY = artCanvas.height / rect.height;
  return { x: xCss * scaleX, y: yCss * scaleY };
}

// events
artCanvas.addEventListener('pointerdown', (e)=>{
  // left button only (button === 0)
  if(e.button !== undefined && e.button !== 0) return;
  pushUndo(); // save state before edit
  isDrawing = true;
  const pos = getPointerPos(e);
  paintCellAt(pos.x, pos.y);
  e.preventDefault();
});
window.addEventListener('pointerup', ()=>{ isDrawing = false; });
artCanvas.addEventListener('pointermove', (e)=>{ if(!isDrawing) return; const pos = getPointerPos(e); paintCellAt(pos.x, pos.y); e.preventDefault(); });

// toolbar actions
document.getElementById('newArt').onclick = ()=>{ pushUndo(); bctx.clearRect(0,0,buffer.width,buffer.height); renderAll(); };
document.getElementById('gridSize').onchange = (e)=>{
  const v = parseInt(e.target.value,10)||64;
  gridCols = v;
  gridRows = v;
  renderAll();
};

// download (renders current buffer + grid)
document.getElementById('download').onclick = ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = artCanvas.width;
  tmp.height = artCanvas.height;
  const tctx = tmp.getContext('2d');

  // fundo branco
  tctx.fillStyle = "white";
  tctx.fillRect(0, 0, tmp.width, tmp.height);

  // arte + grid
  tctx.drawImage(buffer,0,0);
  drawGridOnContext(tctx);

  const link = document.createElement('a');
  link.download = 'pixel_art.png';
  link.href = tmp.toDataURL();
  link.click();
};

// eraser button toggle
const eraserBtn = document.getElementById('eraser');
eraserBtn.onclick = ()=>{ currentColor = (currentColor === 'eraser') ? '#000000' : 'eraser'; eraserBtn.classList.toggle('activeTool', currentColor === 'eraser'); };

// undo/redo buttons
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// color history
function addColorToHistory(hex){ if(!/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)) return; if(!colorHistory.includes(hex)){ colorHistory.push(hex); const div = document.getElementById('colorHistory'); const btn = document.createElement('div'); btn.className='color-btn'; btn.style.background=hex; btn.title=hex; btn.onclick = ()=>{
        currentColor = hex;
        eraserBtn.classList.remove('activeTool');
        document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected'));
        btn.classList.add('selected');
      }; div.appendChild(btn); } }

document.getElementById('addColor').onclick = ()=>{ const hex = document.getElementById('customColor').value.trim(); if(/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex)){ addColorToHistory(hex); currentColor = hex; eraserBtn.classList.remove('activeTool'); document.querySelectorAll('#colorHistory .color-btn').forEach(b=>b.classList.remove('selected')); const last = document.querySelector('#colorHistory .color-btn:last-child'); if(last) last.classList.add('selected'); } else alert('HEX inválido. Use #fff ou #1a2b3c'); };

// create custom grid
document.getElementById('createGrid').onclick = ()=>{
  const w = parseInt(prompt('Largura do grid (colunas):'),10);
  const h = parseInt(prompt('Altura do grid (linhas):'),10);
  if(!w || !h || w<=0 || h<=0) return alert('Valores inválidos');

  gridCols = w;
  gridRows = h;

  artCanvas.width = 640;
  artCanvas.height = Math.round(640 * (h / w));
  buffer.width = artCanvas.width;
  buffer.height = artCanvas.height;

  renderAll();
};

// seed colors
const seeds = ['#000000', '#141414', '#242424', '#333333','#424242', '#5c5c5c','#737373', '#8c8c8c', '#a3a3a3', '#bdbdbd', '#e0e0e0', '#2b3733',
               '#4a5451', '#6b7471','#8e9592', '#b2b7b5', 
               '#140700', '#1e1106', '#311b0c','#462510', '5c3011', '#733a13', '#8b4513','#a26238', '#b8805d','#cc9e83', '#e4a991',
               '#debeab', '#f1cbbc', '#b57d66','#8e6352', '#694a3e','#46322b', '#261d19', '#432422', '#592d2c', '#703735',
              '#6b2700', '#a33c00','#e05200', '#ff7221','#ff8742', '#241400','#573000', '#8f4f01','#d17b11', '#ff8c00','#ffa230', '#ffb357', ,'#ffc37a', '#ffd5a1', 
               '#1c1700', '#453a06','#705e00', '#9e8715', '#bf9f00', '#e3c21b','#ffd500', '#ffe042','#232400', '#5a5c00','#8a8c00', '#bcbf00','#9d9e42', '#bebf6f', 
              '#121a00','#2f3d0a', '#475919','#5c702a', '#90ab4d','#658c00', '#8bbf08','#60a302', '#315400','#102900', '#286300','#42a600', '#051c00','#105700', '#1c9600','#28db00', '#009405', 
              , '#0c4228','#0c6e3e', '#0eab5f','#10e880', '#3af098','#6af7b3', '#001c13', '#014d35', '#11664b', '#2c9473','#00ad76','#508f7b', '#82b8a7', '#024039', '#0f665c','#009c89', '#00c9b2','#00ffe1', '#75d1c6','#a8ede5', 
               '#00757d','#00a7b3', '#2ebfc9','#69cfd6', '#005273','#0082b5', '#1990bf','#00a6e8', '#35bdf2', '#000914', '#001938','#0a284d', '#00316e','#004dab', '#1a68c7','#4480c9', '#000926','#001454', '#152559','#000057', 
               '#000096','#0a0ad1', '#1a009e', '#1d144a','#362b70', '#574999','#897ec2', '#110033','#29007a', '#4000bf','#120021', '#300059','#53009c', '#7208cf','#2e0040', '#5f0085','#8415b0', '#b631eb','#ca57f7', '#d47cf7',
               '#de9ef7', '#e5b7f7','#e5b7f7', '#1c001b','#52004f', '#960091', '#cc02c5','#690050', '#b5008b','#1f0011', '#4d002b','#610d3c', '#8a014f','#ba026a', '#ff0090','#57001e', '#a10e42','#de0d56', 
              '#240000','#570000', '#800000','#ab0000', '#f20202','#521414', '#8f2222', '#d13232','#632d2d', '#964545','#c25555', '#ff7070','#db7d7d', '#ffa8a8','#a17777', '#f0bbbb', 
  '#1a0500', '#1a0900','#1a0e00', '#1a1200','#1a1700', '#161a00','#101a00', '#0a1a00','#001a01', '#001a08', '#001a0f', '#001a15','#00171a', '#00101a','#00081a', '#00011a','#06001a', '#0d001a','#14001a', '#1a0017', '#1a0011', '#1a000a','#1a0003'];
seeds.forEach(addColorToHistory);

// initial
renderAll(); undoStack.push(buffer.toDataURL()); updateUndoRedoButtons();

// keyboard shortcuts: Z undo, X redo, E toggle eraser
window.addEventListener('keydown', (e)=>{
  if(e.key === 'z' || e.key === 'Z') undo();
  if(e.key === 'x' || e.key === 'X') redo();
  if(e.key === 'e' || e.key === 'E'){ currentColor = 'eraser'; document.getElementById('eraser').classList.add('activeTool'); }
});

// right-click paints with eraser (single cell)
artCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const pos = getPointerPos(e);
  pushUndo();
  const old = currentColor;
  currentColor = 'eraser';
  paintCellAt(pos.x, pos.y);
  currentColor = old;
});

// zoom: dblclick (PC) and double-tap (mobile) — mobile requires taps near same spot
let zoomed = false;
function toggleZoom(){ zoomed = !zoomed; if(zoomed){ artCanvas.style.transform = 'scale(2)'; artCanvas.style.transformOrigin = 'center center'; } else { artCanvas.style.transform = 'scale(1)'; } }
artCanvas.addEventListener('dblclick', ()=>{ toggleZoom(); });

let lastTapTime = 0; let lastTapX = 0; let lastTapY = 0;
artCanvas.addEventListener('touchend', (e)=>{
  const now = Date.now();
  const touch = e.changedTouches[0];
  const x = touch.clientX; const y = touch.clientY;
  const dt = now - lastTapTime; const dist = Math.hypot(x - lastTapX, y - lastTapY);
  if(dt < 300 && dist < 25) toggleZoom();
  lastTapTime = now; lastTapX = x; lastTapY = y;
});

</script>
</body>
</html>
